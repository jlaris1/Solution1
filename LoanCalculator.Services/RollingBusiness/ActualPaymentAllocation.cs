using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using LoanAmort_driver.Models;

namespace LoanAmort_driver.RollingBusiness
{
    public class ActualPaymentAllocation
    {
        /// <summary>
        /// Author:Punit Singh
        /// Date:07_June_2017
        /// This class contains functions that will allocate the fund i.e. paid amount, to the past due balances which is added in cuurent period scheduled balance(Now) as per the defined
        /// fields so that next all schedule comes on track. When the amount is exhausted, then I recalculate the output once again...
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="originationFee"></param>
        /// <param name="loanAmountCalc"></param>
        /// <param name="sameDayFee"></param>
        public static void AllocationOfFunds(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable,
                                                 getScheduleOutput outputSchedule)
        {
            StringBuilder sbTracing = new StringBuilder();

            int managementFeeTableIndex = 0;
            int maintenanceFeeTableIndex = 0;
            double managementFeePayable = 0;
            double maintenanceFeePayable = 0;
            int lastManagementFeeChargedIndex = -1;
            int lastMaintenanceFeeChargedIndex = -1;
            try
            {
                int outputGridRowNumber = 0;
                int inputGridRow = 1;
                double totalEarnedFeePerschedule = 0;
                for (inputGridRow = 1; inputGridRow < scheduleInput.InputRecords.Count && scheduleInput.InputRecords[inputGridRow].DateIn <= outputGrid[outputGrid.Count == 1 ? 0 : outputGrid.Count - 1].DueDate; inputGridRow++)
                {
                    // Calculating total earned free per schedule.
                    totalEarnedFeePerschedule = scheduleInput.EarnedLateFee / (scheduleInput.InputRecords.Count() - 1) +
                                                scheduleInput.EarnedNSFFee / (scheduleInput.InputRecords.Count() - 1) +
                                                scheduleInput.EarnedOriginationFee / (scheduleInput.InputRecords.Count() - 1) +
                                                scheduleInput.EarnedSameDayFee / (scheduleInput.InputRecords.Count() - 1) +
                                                scheduleInput.EarnedMaintenanceFee / (scheduleInput.InputRecords.Count() - 1) +
                                                scheduleInput.EarnedManagementFee / (scheduleInput.InputRecords.Count() - 1);

                    if (scheduleInput.InputRecords[inputGridRow].Flags == (int)Constants.FlagValues.Payment || scheduleInput.InputRecords[inputGridRow].Flags == (int)Constants.FlagValues.SkipPayment)
                    {
                        if (inputGridRow == 1)
                        {
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and AllocationOfFunds() method. Calling method :  ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and AllocationOfFunds() method. Calling method :  ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            outputGrid[outputGridRowNumber].ManagementFee = managementFeePayable;
                            outputGrid[outputGridRowNumber].MaintenanceFee = maintenanceFeePayable;
                        }
                        AllocateFundToBuckets(outputGrid, scheduleInput, inputGridRow, defaultTotalAmountToPay, defaultTotalServiceFeePayable, outputGridRowNumber,
                            outputSchedule, ref managementFeeTableIndex, ref maintenanceFeeTableIndex, ref lastManagementFeeChargedIndex, ref lastMaintenanceFeeChargedIndex, totalEarnedFeePerschedule);
                    }
                    outputGridRowNumber++;
                }
                //Calculate all additional payment amount in the schedule and reschedule the all the schedules.
                AdditionalPayment(outputGrid, scheduleInput, defaultTotalAmountToPay, defaultTotalServiceFeePayable, outputSchedule, totalEarnedFeePerschedule);

                int removeIndex = -1;
                for (int startIndex = 0; startIndex <= outputGrid.Count - 1; startIndex++)
                {
                    if (Round.RoundOffAmount(outputGrid[startIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[startIndex].PrincipalPayment <= 0 && outputGrid[startIndex].InterestPayment <= 0 &&
                          outputGrid[startIndex].BeginningServiceFee <= 0 && outputGrid[startIndex].ServiceFee <= 0 && outputGrid[startIndex].ServiceFeeInterest <= 0 &&
                          outputGrid[startIndex].OriginationFee <= 0 && outputGrid[startIndex].SameDayFee <= 0 && outputGrid[startIndex].InterestCarryOver <= 0 &&
                          outputGrid[startIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[startIndex - 1].NSFFeePastDue <= 0 && outputGrid[startIndex - 1].LateFeePastDue <= 0 &&
                          ((scheduleInput.ManagementFeeFrequency == (int)Constants.FeeFrequency.Days || scheduleInput.ManagementFeeFrequency == (int)Constants.FeeFrequency.Months) ? (outputGrid[startIndex == 0 ? startIndex : startIndex - 1].Flags == 0 ? outputGrid[startIndex == 0 ? startIndex : startIndex - 1].ManagementFeePastDue <= 0 : outputGrid[startIndex].ManagementFee <= 0) : (outputGrid[startIndex == 0 ? startIndex : startIndex - 1].ManagementFeePastDue <= 0)) &&
                           ((scheduleInput.MaintenanceFeeFrequency == (int)Constants.FeeFrequency.Days || scheduleInput.MaintenanceFeeFrequency == (int)Constants.FeeFrequency.Months) ? outputGrid[startIndex].MaintenanceFee <= 0 : outputGrid[startIndex == 0 ? startIndex : startIndex - 1].MaintenanceFeePastDue <= 0))
                    {
                        removeIndex = startIndex;
                        break;

                    }
                }
                for (int startIndex = outputGrid.Count - 1; startIndex >= removeIndex; startIndex--)
                {
                    if (removeIndex != -1)
                    {
                        outputGrid.RemoveAt(startIndex);
                    }

                }

                //Calculate earlyPayOff amount on a specific date
                RollingBusiness.EarlyPayOff.EarlyPayOffCalculation(outputGrid, scheduleInput, outputSchedule);
                if (scheduleInput.EarlyPayoffDate == Convert.ToDateTime(Constants.DefaultDate))
                {
                    #region Count index where we can add the new schedule for additional payment.
                    int additionalGridRowIndex = 0;
                    int inputGridRowIndex = 1;
                    lastManagementFeeChargedIndex = -1;
                    lastMaintenanceFeeChargedIndex = -1;
                    managementFeeTableIndex = 0;
                    maintenanceFeeTableIndex = 0;
                    for (int i = 0; i < outputGrid.Count; i++)
                    {
                        if ((outputGrid[i].Flags != (int)Constants.FlagValues.Payment && outputGrid[i].Flags != (int)Constants.FlagValues.SkipPayment))
                        {
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and AllocationOfFunds() method. Calling method :  ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, i, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and AllocationOfFunds() method. Calling method :  ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, i, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            additionalGridRowIndex++;
                        }
                        else
                        {

                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and AllocationOfFunds() method. Calling method :  ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, i, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and AllocationOfFunds() method. Calling method :  ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, i, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            inputGridRowIndex++;
                        }
                    }

                    for (int i = outputSchedule.ManagementFeeAssessment.Count - 1; i > lastManagementFeeChargedIndex; i--)
                    {
                        outputSchedule.ManagementFeeAssessment.RemoveAt(i);
                    }
                    for (int i = outputSchedule.MaintenanceFeeAssessment.Count - 1; i > lastMaintenanceFeeChargedIndex; i--)
                    {
                        outputSchedule.MaintenanceFeeAssessment.RemoveAt(i);
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        /// <summary>
        /// AllocateFundToBuckets() method is used to allocate the funds of a schedule.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="currentInputGridRow"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="currentOutputGridRow"></param>
        /// <param name="originationFee"></param>
        /// <param name="sameDayFee"></param>
        /// <param name="outputSchedule"></param>
        /// <param name="managementFeeTableIndex"></param>
        /// <param name="maintenanceFeeTableIndex"></param>
        /// <param name="lastManagementFeeChargedIndex"></param>
        /// <param name="lastMaintenanceFeeChargedIndex"></param>
        private static void AllocateFundToBuckets(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, int currentInputGridRow, double defaultTotalAmountToPay,
                                                      double defaultTotalServiceFeePayable, int currentOutputGridRow, getScheduleOutput outputSchedule,
                                                      ref int managementFeeTableIndex, ref int maintenanceFeeTableIndex, ref int lastManagementFeeChargedIndex, ref int lastMaintenanceFeeChargedIndex, double totalEarnedFeePerschedule)
        {
            StringBuilder sbTracing = new StringBuilder();
            double totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
            try
            {
                if (currentOutputGridRow == 0)
                {
                    // Calculating Payment due for first schedule with earned fees. 
                    outputGrid[currentOutputGridRow].PaymentDue = outputGrid[currentOutputGridRow].PrincipalPayment + outputGrid[currentOutputGridRow].InterestPayment +
                                                               outputGrid[currentOutputGridRow].ServiceFee + outputGrid[currentOutputGridRow].ServiceFeeInterest +
                                                               outputGrid[currentOutputGridRow].OriginationFee + outputGrid[currentOutputGridRow].SameDayFee +
                                                               outputGrid[currentOutputGridRow].ManagementFee + outputGrid[currentOutputGridRow].MaintenanceFee + totalEarnedFeePerschedule;
                    #region Adding Earned fees to dues fees                                                                                                                                                                       //outputGrid[currentOutputGridRow].NSFFee + outputGrid[currentOutputGridRow].LateFee;
                    outputGrid[currentOutputGridRow].OriginationFee += scheduleInput.EarnedOriginationFee;
                    outputGrid[currentOutputGridRow].SameDayFee += scheduleInput.EarnedSameDayFee;
                    outputGrid[currentOutputGridRow].LateFee += scheduleInput.EarnedLateFee;
                    outputGrid[currentOutputGridRow].NSFFee += scheduleInput.EarnedNSFFee;
                    outputGrid[currentOutputGridRow].MaintenanceFee += scheduleInput.EarnedMaintenanceFee;
                    outputGrid[currentOutputGridRow].ManagementFee += scheduleInput.EarnedManagementFee;
                    #endregion
                    outputGrid[currentOutputGridRow].PaymentDue = Round.RoundOffAmount(outputGrid[currentOutputGridRow].PaymentDue);
                }

                if (currentOutputGridRow == outputGrid.Count - 1 && scheduleInput.Residual > 0)
                {
                    #region  For the Residual principal amount
                    totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                    for (int x = 0; x <= currentOutputGridRow - 1; x++)
                    {

                        totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);

                    }
                    totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                    if (Round.RoundOffAmount(outputGrid[currentOutputGridRow].PrincipalPayment) > totalResidualPrincipal)
                    {
                        outputGrid[currentOutputGridRow].PrincipalPayment = totalResidualPrincipal;
                    }
                    totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                    outputGrid[currentOutputGridRow].PaymentDue = outputGrid[currentOutputGridRow].PrincipalPayment + outputGrid[currentOutputGridRow].InterestPayment +
                                                             outputGrid[currentOutputGridRow].ServiceFee + outputGrid[currentOutputGridRow].ServiceFeeInterest +
                                                             outputGrid[currentOutputGridRow].OriginationFee + outputGrid[currentOutputGridRow].SameDayFee +
                                                             outputGrid[currentOutputGridRow].ManagementFee + outputGrid[currentOutputGridRow].MaintenanceFee +
                                                             outputGrid[currentOutputGridRow].NSFFee + outputGrid[currentOutputGridRow].LateFee;
                    outputGrid[currentOutputGridRow].PaymentDue = Round.RoundOffAmount(outputGrid[currentOutputGridRow].PaymentDue);
                    #endregion
                }

                //Determine the payment amount of the schedule that will be applied all the components as per priority values.
                double paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[currentInputGridRow].PaymentAmount) && scheduleInput.InputRecords[currentInputGridRow].Flags != (int)Constants.FlagValues.SkipPayment ?
                                   (scheduleInput.PaymentAmount > 0 && currentOutputGridRow < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[currentOutputGridRow].PaymentDue) :
                                   (scheduleInput.InputRecords[currentInputGridRow].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[currentInputGridRow].PaymentAmount));


                #region Allocation fund on the basis of priority

                int inputGridRow = currentOutputGridRow + 1;
                for (int i = 1; i <= 10; i++)
                {
                    //Allocate funds to interest amount
                    if (scheduleInput.InputRecords[inputGridRow].InterestPriority == i)
                    {
                        #region
                        double interestAmount = outputGrid[currentOutputGridRow].InterestPayment;
                        if (interestAmount <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].InterestPaid = interestAmount;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(interestAmount);
                            outputGrid[currentOutputGridRow].InterestPastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativeInterestPastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].InterestPaid = paymentAmount;
                            outputGrid[currentOutputGridRow].InterestPastDue = Round.RoundOffAmount((interestAmount - paymentAmount));
                            outputGrid[currentOutputGridRow].CumulativeInterestPastDue = Round.RoundOffAmount((interestAmount - paymentAmount));
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].InterestPaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].InterestPaid);
                        #endregion
                    }

                    //Allocate funds to principal amount
                    else if (scheduleInput.InputRecords[inputGridRow].PrincipalPriority == i)
                    {
                        #region
                        double principalAmount = outputGrid[currentOutputGridRow].PrincipalPayment;

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= currentOutputGridRow - 1; x++)
                            {

                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);

                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal > principalAmount)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - principalAmount);
                            }
                            else
                            {
                                if (totalResidualPrincipal > 0)
                                {
                                    outputGrid[currentOutputGridRow].PrincipalPayment = totalResidualPrincipal;
                                    principalAmount = totalResidualPrincipal;
                                    totalResidualPrincipal = 0;
                                }
                                else
                                {
                                    if (totalResidualPrincipal <= 0 && (outputGrid[currentOutputGridRow].BeginningServiceFee > 0 || outputGrid[currentOutputGridRow - 1].OriginationFeePastDue > 0 || outputGrid[currentOutputGridRow - 1].SameDayFeePastDue > 0 || outputGrid[currentOutputGridRow - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                               outputGrid[currentOutputGridRow - 1].InterestPastDue > 0 || outputGrid[currentOutputGridRow - 1].ServiceFeeInterestPastDue > 0 || outputGrid[currentOutputGridRow - 1].InterestCarryOver > 0 || outputGrid[currentOutputGridRow - 1].MaintenanceFeePastDue > 0 || outputGrid[currentOutputGridRow - 1].ManagementFeePastDue > 0))
                                    {
                                        principalAmount = 0;
                                        totalResidualPrincipal = 0;
                                        outputGrid[currentOutputGridRow].PrincipalPayment = 0;
                                        outputGrid[currentOutputGridRow].PrincipalPaid = 0;
                                    }
                                    else
                                    {
                                        principalAmount = 0;
                                        totalResidualPrincipal = 0;
                                        outputGrid[currentOutputGridRow].InterestAccrued = 0;
                                        outputGrid[currentOutputGridRow].InterestCarryOver = 0;
                                        outputGrid[currentOutputGridRow].PrincipalPaid = 0;
                                        outputGrid[currentOutputGridRow].PrincipalPayment = 0;
                                    }
                                }
                            }
                            #endregion
                        }
                        if (principalAmount <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].PrincipalPaid = principalAmount;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(principalAmount);
                            outputGrid[currentOutputGridRow].PrincipalPastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativePrincipalPastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].PrincipalPaid = paymentAmount;
                            outputGrid[currentOutputGridRow].PrincipalPastDue = Round.RoundOffAmount(principalAmount - paymentAmount);
                            outputGrid[currentOutputGridRow].CumulativePrincipalPastDue = Round.RoundOffAmount(principalAmount - paymentAmount);
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].PrincipalPaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].PrincipalPaid);
                        #endregion
                    }

                    //Allocate funds to Service Fee amount
                    else if (scheduleInput.InputRecords[inputGridRow].ServiceFeePriority == i)
                    {
                        #region
                        double serviceFeeAmount = outputGrid[currentOutputGridRow].ServiceFee;
                        if (serviceFeeAmount <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].ServiceFeePaid = serviceFeeAmount;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(serviceFeeAmount);
                            outputGrid[currentOutputGridRow].ServiceFeePastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativeServiceFeePastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].ServiceFeePaid = paymentAmount;
                            outputGrid[currentOutputGridRow].ServiceFeePastDue = Round.RoundOffAmount(serviceFeeAmount - paymentAmount);
                            outputGrid[currentOutputGridRow].CumulativeServiceFeePastDue = Round.RoundOffAmount(serviceFeeAmount - paymentAmount);
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].ServiceFeePaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].ServiceFeePaid);
                        #endregion
                    }
                    //Allocate funds to NSF Fee amount
                    else if (scheduleInput.InputRecords[inputGridRow].NSFFeePriority == i)
                    {
                        #region
                        double nsfFeeAmount = outputGrid[currentOutputGridRow].NSFFee;
                        if (nsfFeeAmount <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].NSFFeePaid = nsfFeeAmount;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(nsfFeeAmount);
                            outputGrid[currentOutputGridRow].NSFFeePastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativeNSFFeePastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].NSFFeePaid = paymentAmount;
                            outputGrid[currentOutputGridRow].NSFFeePastDue = Round.RoundOffAmount(nsfFeeAmount - paymentAmount);
                            outputGrid[currentOutputGridRow].CumulativeNSFFeePastDue = Round.RoundOffAmount(nsfFeeAmount - paymentAmount);
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].NSFFeePaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].NSFFeePaid);
                        #endregion
                    }
                    //Allocate funds to Late Fee amount
                    else if (scheduleInput.InputRecords[inputGridRow].LateFeePriority == i)
                    {
                        #region
                        double lateFeeAmount = outputGrid[currentOutputGridRow].LateFee;
                        if (lateFeeAmount <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].LateFeePaid = lateFeeAmount;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(lateFeeAmount);
                            outputGrid[currentOutputGridRow].LateFeePastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativeLateFeePastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].LateFeePaid = paymentAmount;
                            outputGrid[currentOutputGridRow].LateFeePastDue = Round.RoundOffAmount((lateFeeAmount - paymentAmount));
                            outputGrid[currentOutputGridRow].CumulativeLateFeePastDue = Round.RoundOffAmount(lateFeeAmount - paymentAmount);
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].LateFeePaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].LateFeePaid);
                        #endregion
                    }
                    //Allocate funds to Service Fee Interest amount
                    else if (scheduleInput.InputRecords[inputGridRow].ServiceFeeInterestPriority == i)
                    {
                        #region
                        double serviceFeeInterestAmount = outputGrid[currentOutputGridRow].ServiceFeeInterest;
                        if (serviceFeeInterestAmount <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].ServiceFeeInterestPaid = serviceFeeInterestAmount;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(serviceFeeInterestAmount);
                            outputGrid[currentOutputGridRow].ServiceFeeInterestPastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativeServiceFeeInterestPastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].ServiceFeeInterestPaid = paymentAmount;
                            outputGrid[currentOutputGridRow].ServiceFeeInterestPastDue = Round.RoundOffAmount((serviceFeeInterestAmount - paymentAmount));
                            outputGrid[currentOutputGridRow].CumulativeServiceFeeInterestPastDue = Round.RoundOffAmount((serviceFeeInterestAmount - paymentAmount));
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].ServiceFeeInterestPaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].ServiceFeeInterestPaid);
                        #endregion
                    }

                    //Allocate funds to Origination Fee amount
                    else if (scheduleInput.InputRecords[inputGridRow].OriginationFeePriority == i)
                    {
                        #region
                        if (outputGrid[currentOutputGridRow].OriginationFee <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].OriginationFeePaid = outputGrid[currentOutputGridRow].OriginationFee;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[currentOutputGridRow].OriginationFee);
                            outputGrid[currentOutputGridRow].OriginationFeePastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativeOriginationFeePastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].OriginationFeePaid = paymentAmount;
                            outputGrid[currentOutputGridRow].OriginationFeePastDue = Round.RoundOffAmount((outputGrid[currentOutputGridRow].OriginationFee - paymentAmount));
                            outputGrid[currentOutputGridRow].CumulativeOriginationFeePastDue = Round.RoundOffAmount((outputGrid[currentOutputGridRow].OriginationFee - paymentAmount));
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].OriginationFeePaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].OriginationFeePaid);
                        #endregion
                    }

                    //Allocate funds to Management Fee amount
                    else if (scheduleInput.InputRecords[inputGridRow].ManagementFeePriority == i)
                    {
                        #region
                        if (outputGrid[currentOutputGridRow].ManagementFee <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].ManagementFeePaid = outputGrid[currentOutputGridRow].ManagementFee;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[currentOutputGridRow].ManagementFee);
                            outputGrid[currentOutputGridRow].ManagementFeePastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativeManagementFeePastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].ManagementFeePaid = paymentAmount;
                            outputGrid[currentOutputGridRow].ManagementFeePastDue = Round.RoundOffAmount((outputGrid[currentOutputGridRow].ManagementFee - paymentAmount));
                            outputGrid[currentOutputGridRow].CumulativeManagementFeePastDue = Round.RoundOffAmount((outputGrid[currentOutputGridRow].ManagementFee - paymentAmount));
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].ManagementFeePaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].ManagementFeePaid);
                        #endregion
                    }

                    //Allocate funds to Maintenance Fee amount
                    else if (scheduleInput.InputRecords[inputGridRow].MaintenanceFeePriority == i)
                    {
                        #region
                        if (outputGrid[currentOutputGridRow].MaintenanceFee <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].MaintenanceFeePaid = outputGrid[currentOutputGridRow].MaintenanceFee;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[currentOutputGridRow].MaintenanceFee);
                            outputGrid[currentOutputGridRow].MaintenanceFeePastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativeMaintenanceFeePastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].MaintenanceFeePaid = paymentAmount;
                            outputGrid[currentOutputGridRow].MaintenanceFeePastDue = Round.RoundOffAmount(outputGrid[currentOutputGridRow].MaintenanceFee - paymentAmount);
                            outputGrid[currentOutputGridRow].CumulativeMaintenanceFeePastDue = Round.RoundOffAmount(outputGrid[currentOutputGridRow].MaintenanceFee - paymentAmount);
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].MaintenanceFeePaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].MaintenanceFeePaid);
                        #endregion
                    }

                    //Allocate funds to Same Day Fee amount
                    else if (scheduleInput.InputRecords[inputGridRow].SameDayFeePriority == i)
                    {
                        #region
                        if (outputGrid[currentOutputGridRow].SameDayFee <= paymentAmount)
                        {
                            outputGrid[currentOutputGridRow].SameDayFeePaid = outputGrid[currentOutputGridRow].SameDayFee;
                            paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[currentOutputGridRow].SameDayFee);
                            outputGrid[currentOutputGridRow].SameDayFeePastDue = 0;
                            outputGrid[currentOutputGridRow].CumulativeSameDayFeePastDue = 0;
                        }
                        else
                        {
                            outputGrid[currentOutputGridRow].SameDayFeePaid = paymentAmount;
                            outputGrid[currentOutputGridRow].SameDayFeePastDue = Round.RoundOffAmount(outputGrid[currentOutputGridRow].SameDayFee - paymentAmount);
                            outputGrid[currentOutputGridRow].CumulativeSameDayFeePastDue = Round.RoundOffAmount(outputGrid[currentOutputGridRow].SameDayFee - paymentAmount);
                            paymentAmount = 0;
                        }
                        outputGrid[currentOutputGridRow].SameDayFeePaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].SameDayFeePaid);
                        #endregion
                    }
                }

                #endregion

                if (currentOutputGridRow == outputGrid.Count - 1)
                {
                    outputGrid[currentOutputGridRow].PaymentDue = outputGrid[currentOutputGridRow].PrincipalPayment + outputGrid[currentOutputGridRow].InterestPayment +
                                                              outputGrid[currentOutputGridRow].ServiceFee + outputGrid[currentOutputGridRow].ServiceFeeInterest +
                                                              outputGrid[currentOutputGridRow].OriginationFee + outputGrid[currentOutputGridRow].SameDayFee +
                                                              outputGrid[currentOutputGridRow].NSFFee + outputGrid[currentOutputGridRow].LateFee +
                                                              outputGrid[currentOutputGridRow].ManagementFee + outputGrid[currentOutputGridRow].MaintenanceFee;
                    outputGrid[currentOutputGridRow].PaymentDue = Round.RoundOffAmount(outputGrid[currentOutputGridRow].PaymentDue);

                    outputGrid[currentOutputGridRow].ServiceFeeTotal = Round.RoundOffAmount(outputGrid[currentOutputGridRow].ServiceFee + outputGrid[currentOutputGridRow].ServiceFeeInterest);
                }

                outputGrid[currentOutputGridRow].TotalPayment = outputGrid[currentOutputGridRow].PrincipalPayment + outputGrid[currentOutputGridRow].InterestPayment +
                                                               outputGrid[currentOutputGridRow].ServiceFee + outputGrid[currentOutputGridRow].ServiceFeeInterest +
                                                               outputGrid[currentOutputGridRow].OriginationFee + outputGrid[currentOutputGridRow].SameDayFee +
                                                               outputGrid[currentOutputGridRow].ManagementFee + outputGrid[currentOutputGridRow].MaintenanceFee +
                                                               outputGrid[currentOutputGridRow].NSFFee + outputGrid[currentOutputGridRow].LateFee;
                outputGrid[currentOutputGridRow].TotalPayment = Round.RoundOffAmount(outputGrid[currentOutputGridRow].TotalPayment);

                #region If Payment amount get remains after all priority allocation have done for a schedule
                double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[currentOutputGridRow].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[currentOutputGridRow].PrincipalPaid));
                double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[currentOutputGridRow].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[currentOutputGridRow].ServiceFeePaid));
                if (currentOutputGridRow != outputGrid.Count - 1)

                {
                    for (int startindex = 1; startindex <= 10; startindex++)
                    {
                        if (scheduleInput.InputRecords[currentInputGridRow].PrincipalPriority == startindex)
                        {
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;

                            if (paymentAmount >= remainningCurrentBegnningPrincipal)
                            {
                                outputGrid[currentOutputGridRow].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                outputGrid[currentOutputGridRow + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[currentOutputGridRow].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[currentOutputGridRow].PrincipalPaid)) : 0;
                                paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                totalResidualPrincipal = 0;

                            }
                            else
                            {
                                if (paymentAmount > 0)
                                {
                                    outputGrid[currentOutputGridRow].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                    outputGrid[currentOutputGridRow + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                    paymentAmount = 0;
                                    totalResidualPrincipal = 0;
                                }
                            }
                        }
                        if (scheduleInput.InputRecords[currentInputGridRow].ServiceFeePriority == startindex)
                        {
                            if (paymentAmount >= remainningCurrentBeginningServiceFee)
                            {
                                outputGrid[currentOutputGridRow].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                outputGrid[currentOutputGridRow + 1].BeginningServiceFee = 0;
                                paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                            }
                            else
                            {
                                if (paymentAmount > 0)
                                {
                                    outputGrid[currentOutputGridRow].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                    outputGrid[currentOutputGridRow + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                    paymentAmount = 0;
                                }
                            }
                        }
                    }
                }
                #endregion

                outputGrid[currentOutputGridRow].TotalPaid = outputGrid[currentOutputGridRow].PrincipalPaid + outputGrid[currentOutputGridRow].InterestPaid +
                                                             outputGrid[currentOutputGridRow].ServiceFeePaid + outputGrid[currentOutputGridRow].ServiceFeeInterestPaid +
                                                             outputGrid[currentOutputGridRow].OriginationFeePaid + outputGrid[currentOutputGridRow].MaintenanceFeePaid +
                                                             outputGrid[currentOutputGridRow].ManagementFeePaid + outputGrid[currentOutputGridRow].SameDayFeePaid +
                                                             outputGrid[currentOutputGridRow].NSFFeePaid + outputGrid[currentOutputGridRow].LateFeePaid;
                outputGrid[currentOutputGridRow].TotalPaid = Round.RoundOffAmount(outputGrid[currentOutputGridRow].TotalPaid);
                outputGrid[currentOutputGridRow].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[currentOutputGridRow].ServiceFee + outputGrid[currentOutputGridRow].ServiceFeeInterest));

                if (currentOutputGridRow < outputGrid.Count - 1)
                {
                    RepaymentReschedule(outputGrid, scheduleInput, defaultTotalAmountToPay, defaultTotalServiceFeePayable, currentOutputGridRow,
                                        outputSchedule, ref managementFeeTableIndex, ref maintenanceFeeTableIndex, ref lastManagementFeeChargedIndex,
                                        ref lastMaintenanceFeeChargedIndex, currentInputGridRow, totalEarnedFeePerschedule);
                }
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }

        }

        /// <summary>
        /// RepaymentReschedule() method is used to do the repayment schedule caculation.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="index"></param>
        /// <param name="originationFee"></param>
        /// <param name="sameDayFee"></param>
        /// <param name="outputSchedule"></param>
        /// <param name="managementFeeTableIndex"></param>
        /// <param name="maintenanceFeeTableIndex"></param>
        /// <param name="lastManagementFeeChargedIndex"></param>
        /// <param name="lastMaintenanceFeeChargedIndex"></param>
        /// <param name="currentInputGridRow"></param>
        private static void RepaymentReschedule(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable, int index,
                                                  getScheduleOutput outputSchedule, ref int managementFeeTableIndex, ref int maintenanceFeeTableIndex,
                                                 ref int lastManagementFeeChargedIndex, ref int lastMaintenanceFeeChargedIndex, int currentInputGridRow, double totalEarnedFeePerschedule)
        {
            StringBuilder sbTracing = new StringBuilder();
            try
            {
                double managementFeePayable = 0;
                double maintenanceFeePayable = 0;
                double begnningPrincipal = Round.RoundOffAmount(outputGrid[0].BeginningPrincipal);
                double begnningServiceFee = Round.RoundOffAmount(outputGrid[0].BeginningServiceFee);
                //Default end date.
                DateTime endDate = Convert.ToDateTime(Constants.DefaultDate);
                double totalAmountToPay = Round.RoundOffAmount(defaultTotalAmountToPay);
                double totalServiceFeePayable = Round.RoundOffAmount(defaultTotalServiceFeePayable);
                double principalPayment = 0;
                double intrestAccreued = 0.0;
                double serviceFeeInterest = 0.0;
                double interestCarryOver = 0;
                double serviceFee = 0;
                double serviceFeeInterestCarryover = 0;
                double totalResidualPrincipal = 0;
                double serviceFeeTotal = Round.RoundOffAmount(outputGrid[index + 1].ServiceFeeTotal);

                outputGrid[index + 1].BeginningPrincipal = outputGrid[index].PrincipalPaid == 0 ? Round.RoundOffAmount(outputGrid[index].BeginningPrincipal) : Round.RoundOffAmount(outputGrid[index].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[index].PrincipalPaid);
                outputGrid[index + 1].BeginningServiceFee = outputGrid[index].ServiceFeePaid == 0 ? Round.RoundOffAmount(outputGrid[index].BeginningServiceFee) : Round.RoundOffAmount(outputGrid[index].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[index].ServiceFeePaid);

                sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and RepaymentReschedule() method. Calling method :  ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, index + 1, currentInputGridRow + 1, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and RepaymentReschedule() method. Calling method :  ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, index + 1, currentInputGridRow + 1, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                outputGrid[index + 1].ManagementFee = managementFeePayable;
                outputGrid[index + 1].MaintenanceFee = maintenanceFeePayable;


                #region Calculate Periodic Interest rate
                //int j = scheduleInput.InputRecords.FindIndex(o => o.DateIn == outputGrid[index].DueDate);
                //It determines the start date from which interest will be calculated for that period. If it is first scheduled payment, then "DateIn" column in input 
                //grid will considered as start date, otherwise last end date will be considered.
                DateTime startDate = outputGrid[index].PaymentDate;

                //It determines the end date. Interest will be calculated till the end date for that period.
                endDate = outputGrid[index + 1].PaymentDate;
                //This variable calls a function which calculate the periodic interest rate for that period.
                double periodicInterestRate = 0;
                if (string.IsNullOrEmpty(scheduleInput.InputRecords[index + 2].InterestRate))
                {
                    sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and RepaymentReschedule() method. Calling method : CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[index + 1].BeginningPrincipal, true, false);");
                    periodicInterestRate = CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[index + 1].BeginningPrincipal, true, true, false);
                }
                else
                {
                    if (scheduleInput.InputRecords[index + 2].InterestRate == "0")
                    {
                        totalAmountToPay = Round.RoundOffAmount(begnningPrincipal / (scheduleInput.InputRecords.Count - 1));
                        totalServiceFeePayable = Round.RoundOffAmount(begnningServiceFee / (scheduleInput.InputRecords.Count - 1));
                    }
                    sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and RepaymentReschedule() method. Calling method : CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, " +
                        "Convert.ToDouble(scheduleInput.InputRecords[index + 2].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false);");
                    periodicInterestRate = CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[index + 2].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                }

                #endregion
                double scheduledBegnningPrinciple = outputGrid[index].PrincipalPaid == 0 ? Round.RoundOffAmount(outputGrid[index].BeginningPrincipal) : Round.RoundOffAmount(outputGrid[index].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[index].PrincipalPaid);
                double scheduledBegnningServiceFeePrinciple = outputGrid[index].ServiceFeePaid == 0 ? Round.RoundOffAmount(outputGrid[index].BeginningServiceFee) : Round.RoundOffAmount(outputGrid[index].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[index].ServiceFeePaid);
                #region calculates the daily interest rate and interest amount for the period

                //To calculate the interestAccrued using tier intrest rate.
                intrestAccreued = string.IsNullOrEmpty(scheduleInput.InputRecords[index + 2].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, scheduledBegnningPrinciple, true, true, false) :
                                  PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[index + 2].InterestRate), scheduleInput.InputRecords[0].DateIn, scheduledBegnningPrinciple, true, true, false);
                intrestAccreued = Round.RoundOffAmount(intrestAccreued);

                //This variable calculates the daily interest rate for the period.
                sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and RepaymentReschedule() method. Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                    "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                double dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);

                //This variable calculates the daily interest amount for the period.
                sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and RepaymentReschedule() method. Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                    "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                double dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, intrestAccreued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                #endregion

                #region Calculate the Interest Accrued for particular schedule
                if (scheduleInput.Residual > 0)
                {
                    #region  For the Residual operation calculate begnning principal amount
                    totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                    for (int x = 0; x <= index; x++)
                    {
                        totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                    }
                    totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                    if (totalResidualPrincipal <= 0 && scheduledBegnningServiceFeePrinciple <= 0 && outputGrid[index].OriginationFeePastDue <= 0 && outputGrid[index].SameDayFeePastDue <= 0 && outputGrid[index].AccruedServiceFeeInterestCarryOver <= 0 &&
                               outputGrid[index].InterestPastDue <= 0 && outputGrid[index].ServiceFeeInterestPastDue <= 0 && outputGrid[index].InterestCarryOver <= 0 && outputGrid[index].MaintenanceFeePastDue <= 0 && outputGrid[index].ManagementFeePastDue <= 0)
                    {
                        scheduledBegnningPrinciple = 0;
                        dailyInterestAmount = 0;
                    }
                    #endregion
                }

                // calculating serviceFeeInterest using tier intrest rate.
                serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                    (string.IsNullOrEmpty(scheduleInput.InputRecords[index + 2].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, scheduledBegnningServiceFeePrinciple, true, true, false) :
                                  PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[index + 2].InterestRate), scheduleInput.InputRecords[0].DateIn, scheduledBegnningServiceFeePrinciple, true, true, false));

                serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                interestCarryOver = Round.RoundOffAmount(outputGrid[index].InterestCarryOver);
                serviceFeeInterestCarryover = Round.RoundOffAmount(outputGrid[index].AccruedServiceFeeInterestCarryOver);

                outputGrid[index + 1].InterestAccrued = intrestAccreued;
                outputGrid[index + 1].AccruedServiceFeeInterest = serviceFeeInterest;
                if (index + 1 != outputGrid.Count - 1)
                {
                    #region calculate Principal Amount and Interest Accrued and interestCarryOver amount

                    if ((intrestAccreued + interestCarryOver) >= totalAmountToPay)
                    {
                        interestCarryOver = Round.RoundOffAmount(intrestAccreued + interestCarryOver) - (totalAmountToPay);
                        outputGrid[index + 1].InterestCarryOver = Round.RoundOffAmount(interestCarryOver);
                        intrestAccreued = Round.RoundOffAmount(totalAmountToPay);
                        principalPayment = 0;
                        outputGrid[index + 1].PrincipalPayment = principalPayment;
                    }
                    else
                    {
                        if ((intrestAccreued + interestCarryOver + (scheduleInput.Residual > 0 ? totalResidualPrincipal : scheduledBegnningPrinciple)) > totalAmountToPay)
                        {
                            principalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((intrestAccreued + interestCarryOver));
                            outputGrid[index + 1].PrincipalPayment = Round.RoundOffAmount(principalPayment);
                            intrestAccreued = Round.RoundOffAmount(intrestAccreued + interestCarryOver);
                            interestCarryOver = 0;
                            outputGrid[index + 1].InterestCarryOver = interestCarryOver;
                        }
                        else
                        {
                            principalPayment = Round.RoundOffAmount((scheduleInput.Residual > 0 ? totalResidualPrincipal : scheduledBegnningPrinciple));
                            outputGrid[index + 1].PrincipalPayment = Round.RoundOffAmount(principalPayment);
                            intrestAccreued = Round.RoundOffAmount((intrestAccreued + interestCarryOver));
                            interestCarryOver = 0;
                            outputGrid[index + 1].InterestCarryOver = interestCarryOver;
                        }
                    }

                    #endregion
                    #region calculate serviceFee Amount and ServiceFeeInterest and serviceFeeInterestCarryover amount
                    if (scheduleInput.ServiceFeeFirstPayment)
                    {
                        outputGrid[index + 1].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest) + Round.RoundOffAmount(outputGrid[index].ServiceFeeInterestPastDue);
                        outputGrid[index + 1].ServiceFee = Round.RoundOffAmount(scheduledBegnningServiceFeePrinciple);
                        outputGrid[index + 1].serviceFeeInterestCarryOver = 0;
                        totalServiceFeePayable = Round.RoundOffAmount(serviceFeeInterest) + outputGrid[index + 1].ServiceFee;
                    }
                    else if ((serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable)
                    {
                        serviceFeeInterestCarryover = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover)) - (totalServiceFeePayable);
                        outputGrid[index + 1].serviceFeeInterestCarryOver = Round.RoundOffAmount(serviceFeeInterestCarryover);
                        serviceFeeInterest = Round.RoundOffAmount(totalServiceFeePayable);
                        serviceFee = 0;
                        outputGrid[index + 1].ServiceFee = serviceFee;
                    }
                    else
                    {
                        if ((serviceFeeInterest + serviceFeeInterestCarryover + scheduledBegnningServiceFeePrinciple) > totalServiceFeePayable)
                        {
                            serviceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                            outputGrid[index + 1].ServiceFee = Round.RoundOffAmount(serviceFee);
                            serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                            serviceFeeInterestCarryover = 0;
                            outputGrid[index + 1].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                        }
                        else
                        {
                            serviceFee = Round.RoundOffAmount(scheduledBegnningServiceFeePrinciple);
                            outputGrid[index + 1].ServiceFee = Round.RoundOffAmount(serviceFee);
                            serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                            serviceFeeInterestCarryover = 0;
                            outputGrid[index + 1].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                        }
                    }
                    #endregion
                }
                #endregion

                #region Allocate amount for the schedule
                if (scheduleInput.Residual > 0)
                {
                    #region  For the Residual principal amount
                    totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                    double principalAmount = outputGrid[index + 1].PrincipalPayment;
                    for (int x = 0; x <= index; x++)
                    {
                        totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                    }
                    totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                    if (totalResidualPrincipal > principalAmount)
                    {
                        totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - principalAmount);
                    }
                    else
                    {
                        if (totalResidualPrincipal > 0)
                        {
                            outputGrid[index + 1].PrincipalPayment = totalResidualPrincipal;
                            totalResidualPrincipal = 0;
                        }
                        else
                        {
                            if (totalResidualPrincipal == 0 && (scheduledBegnningServiceFeePrinciple > 0 || outputGrid[index].OriginationFeePastDue > 0 || outputGrid[index].SameDayFeePastDue > 0 || outputGrid[index].AccruedServiceFeeInterestCarryOver > 0 ||
                                outputGrid[index].InterestPastDue > 0 || outputGrid[index].ServiceFeeInterestPastDue > 0 || outputGrid[index].InterestCarryOver > 0 || outputGrid[index].MaintenanceFeePastDue > 0 || outputGrid[index].ManagementFeePastDue > 0))
                            {
                                totalResidualPrincipal = 0;
                                outputGrid[index + 1].PrincipalPayment = 0;
                            }
                            else
                            {
                                totalResidualPrincipal = 0;
                                outputGrid[index + 1].InterestAccrued = 0;
                                intrestAccreued = (index + 1) == (outputGrid.Count - 1) ? 0 : outputGrid[index].InterestCarryOver;
                                outputGrid[index + 1].InterestCarryOver = 0;
                                outputGrid[index + 1].InterestPayment = 0;
                                outputGrid[index + 1].InterestPaid = 0;
                                outputGrid[index + 1].PrincipalPayment = 0;
                            }
                        }
                    }

                    #endregion
                }
                outputGrid[index + 1].NSFFee = Round.RoundOffAmount(outputGrid[index].NSFFeePastDue);
                outputGrid[index + 1].LateFee = Round.RoundOffAmount(outputGrid[index].LateFeePastDue);
                outputGrid[index + 1].OriginationFee = Round.RoundOffAmount(outputGrid[index].OriginationFeePastDue);
                outputGrid[index + 1].SameDayFee = Round.RoundOffAmount(outputGrid[index].SameDayFeePastDue);
                outputGrid[index + 1].BeginningPrincipal = Round.RoundOffAmount(outputGrid[index].BeginningPrincipal - outputGrid[index].PrincipalPaid);
                outputGrid[index + 1].PrincipalPayment = scheduledBegnningPrinciple == 0 ? 0 : scheduledBegnningPrinciple <= Round.RoundOffAmount(outputGrid[index + 1].PrincipalPayment) ? scheduledBegnningPrinciple : Round.RoundOffAmount(outputGrid[index + 1].PrincipalPayment) + Round.RoundOffAmount(outputGrid[index].PrincipalPastDue);
                outputGrid[index + 1].PrincipalPayment = scheduledBegnningPrinciple < outputGrid[index + 1].PrincipalPayment ? scheduledBegnningPrinciple : outputGrid[index + 1].PrincipalPayment;
                outputGrid[index + 1].InterestPayment = Round.RoundOffAmount(intrestAccreued) + Round.RoundOffAmount(outputGrid[index].InterestPastDue);
                outputGrid[index + 1].PeriodicInterestRate = periodicInterestRate;
                outputGrid[index + 1].DailyInterestRate = dailyInterestRate;
                outputGrid[index + 1].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                outputGrid[index + 1].BeginningServiceFee = scheduledBegnningServiceFeePrinciple;
                outputGrid[index + 1].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest) + Round.RoundOffAmount(outputGrid[index].ServiceFeeInterestPastDue);
                outputGrid[index + 1].ServiceFee = Round.RoundOffAmount(outputGrid[index + 1].ServiceFee);
                outputGrid[index + 1].PaymentDue = totalAmountToPay + totalServiceFeePayable +
                                                              ((outputGrid[index + 1].OriginationFee - scheduleInput.EarnedOriginationFee) <= 0 ? 0 : (outputGrid[index + 1].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                              ((outputGrid[index + 1].SameDayFee - scheduleInput.EarnedSameDayFee) <= 0 ? 0 : (outputGrid[index + 1].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                              outputGrid[index + 1].ManagementFee + outputGrid[index + 1].MaintenanceFee + totalEarnedFeePerschedule;
                outputGrid[index + 1].PaymentDue = Round.RoundOffAmount(outputGrid[index + 1].PaymentDue);
                outputGrid[index + 1].MaintenanceFee += Round.RoundOffAmount(outputGrid[index].MaintenanceFeePastDue);
                outputGrid[index + 1].ManagementFee += Round.RoundOffAmount(outputGrid[index].ManagementFeePastDue);

                double sumOfServiceFeeAndinterest = Round.RoundOffAmount((outputGrid[index + 1].ServiceFee + outputGrid[index].ServiceFeePastDue + outputGrid[index + 1].ServiceFeeInterest));
                if (scheduleInput.ServiceFeeFirstPayment)
                {
                    outputGrid[index + 1].ServiceFee = outputGrid[index + 1].ServiceFee;
                }
                else if (scheduledBegnningServiceFeePrinciple == 0)
                {
                    outputGrid[index + 1].ServiceFee = 0;
                }
                else if ((scheduledBegnningServiceFeePrinciple > sumOfServiceFeeAndinterest) && (serviceFeeTotal > sumOfServiceFeeAndinterest))
                {
                    outputGrid[index + 1].ServiceFee = serviceFeeTotal - outputGrid[index + 1].ServiceFeeInterest;
                }
                else if ((serviceFeeTotal > sumOfServiceFeeAndinterest) && (scheduledBegnningServiceFeePrinciple > 0) && (scheduledBegnningServiceFeePrinciple < serviceFeeTotal))
                {
                    outputGrid[index + 1].ServiceFee = scheduledBegnningServiceFeePrinciple;
                }
                else
                {
                    outputGrid[index + 1].ServiceFee = outputGrid[index + 1].ServiceFee + outputGrid[index].ServiceFeePastDue;
                }
                outputGrid[index + 1].ServiceFee = scheduledBegnningServiceFeePrinciple < outputGrid[index + 1].ServiceFee ? scheduledBegnningServiceFeePrinciple : outputGrid[index + 1].ServiceFee;
                #endregion

                #region Calculate EnforcementPrincipal Amount
                if (index + 1 >= (scheduleInput.EnforcedPayment - 1) && outputGrid[index + 1].PrincipalPayment == 0 && outputGrid[index + 1].InterestPayment > 0 && index + 1 != outputGrid.Count - 1)
                {
                    outputGrid[index + 1].PrincipalPayment = outputGrid[index + 1].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[index + 1].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);

                    if (scheduleInput.Residual > 0)
                    {
                        outputGrid[index + 1].PrincipalPayment = totalResidualPrincipal >= outputGrid[index + 1].PrincipalPayment ? outputGrid[index + 1].PrincipalPayment : totalResidualPrincipal;
                    }
                    else
                    {
                        outputGrid[index + 1].PrincipalPayment = outputGrid[index + 1].BeginningPrincipal >= outputGrid[index + 1].PrincipalPayment ? outputGrid[index + 1].PrincipalPayment : outputGrid[index + 1].BeginningPrincipal;
                    }
                    outputGrid[index + 1].InterestPayment -= outputGrid[index + 1].PrincipalPayment;
                    outputGrid[index + 1].InterestCarryOver += outputGrid[index + 1].PrincipalPayment;
                    outputGrid[index + 1].PrincipalPayment = outputGrid[index + 1].PrincipalPayment <= 0 ? 0 : outputGrid[index + 1].PrincipalPayment;

                }
                #endregion

                #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro
                if (Round.RoundOffAmount(outputGrid[index + 1].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[index + 1].PrincipalPayment <= 0 && outputGrid[index + 1].InterestPayment <= 0 &&
                    outputGrid[index + 1].BeginningServiceFee <= 0 && outputGrid[index + 1].ServiceFee <= 0 && outputGrid[index + 1].ServiceFeeInterest <= 0 &&
                    outputGrid[index + 1].OriginationFee <= 0 && outputGrid[index + 1].SameDayFee <= 0 && outputGrid[index].MaintenanceFeePastDue <= 0 && outputGrid[index].ManagementFeePastDue <= 0)
                {
                    outputGrid[index].PrincipalPayment = outputGrid[index].PrincipalPaid;
                    outputGrid[index].InterestPayment = outputGrid[index].InterestPaid;
                    outputGrid[index].ServiceFee = outputGrid[index].ServiceFeePaid;
                    outputGrid[index].ServiceFeeInterest = outputGrid[index].ServiceFeeInterestPaid;
                    outputGrid[index].OriginationFee = outputGrid[index].OriginationFeePaid;
                    outputGrid[index].SameDayFee = outputGrid[index].SameDayFeePaid;
                    outputGrid[index].MaintenanceFee = outputGrid[index].MaintenanceFeePaid;
                    outputGrid[index].ManagementFee = outputGrid[index].ManagementFeePaid;
                    outputGrid[index].PaymentDue = outputGrid[index].PrincipalPayment + outputGrid[index].InterestPayment +
                                                   outputGrid[index].ServiceFee + outputGrid[index].ServiceFeeInterest +
                                                   outputGrid[index].OriginationFee + outputGrid[index].SameDayFee +
                                                   outputGrid[index].MaintenanceFee + outputGrid[index].ManagementFee +
                                                   outputGrid[index].NSFFee + outputGrid[index].LateFee;
                    outputGrid[index].PaymentDue = Round.RoundOffAmount(outputGrid[index].PaymentDue);
                    outputGrid[index].TotalPayment = outputGrid[index].PrincipalPayment + outputGrid[index].InterestPayment +
                                                   outputGrid[index].ServiceFee + outputGrid[index].ServiceFeeInterest +
                                                   outputGrid[index].OriginationFee + outputGrid[index].SameDayFee +
                                                   outputGrid[index].MaintenanceFee + outputGrid[index].ManagementFee +
                                                   outputGrid[index].NSFFee + outputGrid[index].LateFee;
                    outputGrid[index].TotalPayment = Round.RoundOffAmount(outputGrid[index].TotalPayment);
                    outputGrid[index].ServiceFeeTotal = outputGrid[index].ServiceFee + outputGrid[index].ServiceFeeInterest;
                    outputGrid[index].ServiceFeeTotal = Round.RoundOffAmount(outputGrid[index].ServiceFeeTotal);
                }
                #endregion

                if ((index + 1) == outputGrid.Count - 1)
                {
                    #region
                    outputGrid[index + 1].InterestPayment = Round.RoundOffAmount((intrestAccreued + interestCarryOver)) + Round.RoundOffAmount(outputGrid[index].InterestPastDue);
                    outputGrid[index + 1].InterestCarryOver = 0;
                    outputGrid[index + 1].PrincipalPayment = scheduledBegnningPrinciple;
                    outputGrid[index + 1].ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover)) + Round.RoundOffAmount(outputGrid[index].ServiceFeeInterestPastDue);
                    outputGrid[index + 1].AccruedServiceFeeInterestCarryOver = 0;
                    outputGrid[index + 1].ServiceFee = scheduledBegnningServiceFeePrinciple;
                    outputGrid[index + 1].PaymentDue = outputGrid[index + 1].PrincipalPayment + outputGrid[index + 1].InterestPayment +
                                                              outputGrid[index + 1].ServiceFee + outputGrid[index + 1].ServiceFeeInterest +
                                                              outputGrid[index + 1].OriginationFee + outputGrid[index + 1].SameDayFee +
                                                              outputGrid[index + 1].ManagementFee + outputGrid[index + 1].MaintenanceFee +
                                                              outputGrid[index + 1].NSFFee + outputGrid[index + 1].LateFee;
                    outputGrid[index + 1].PaymentDue = Round.RoundOffAmount(outputGrid[index + 1].PaymentDue);
                    outputGrid[index + 1].TotalPayment = Round.RoundOffAmount(outputGrid[index + 1].PaymentDue);
                    #endregion
                }
                outputGrid[index + 1].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[index + 1].ServiceFee + outputGrid[index + 1].ServiceFeeInterest));
                outputGrid[index].TotalPaid = outputGrid[index].PrincipalPaid + outputGrid[index].InterestPaid +
                                                            outputGrid[index].ServiceFeePaid + outputGrid[index].ServiceFeeInterestPaid +
                                                            outputGrid[index].OriginationFeePaid + outputGrid[index].MaintenanceFeePaid +
                                                            outputGrid[index].ManagementFeePaid + outputGrid[index].SameDayFeePaid +
                                                            outputGrid[index].NSFFeePaid + outputGrid[index].LateFeePaid;
                outputGrid[index].TotalPaid = Round.RoundOffAmount(outputGrid[index].TotalPaid);
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }

        }

        /// <summary>
        /// AdditionalPayment() method call all the additionals functions according to flag basis.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="outputSchedule"></param>
        private static void AdditionalPayment(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable, getScheduleOutput outputSchedule, double totalEarnedFeePerschedule)
        {
            StringBuilder sbTracing = new StringBuilder();
            try
            {

                for (int additionalIndex = 0; additionalIndex < scheduleInput.AdditionalPaymentRecords.Count; additionalIndex++)
                {

                    switch (scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags)
                    {
                        case (int)Constants.FlagValues.PrincipalOnly:
                            //When we goes only for principal payment only
                            PrincipalOnlyPayment(outputGrid, scheduleInput, scheduleInput.AdditionalPaymentRecords[additionalIndex].DateIn, scheduleInput.AdditionalPaymentRecords[additionalIndex].AdditionalPayment, additionalIndex, defaultTotalAmountToPay, defaultTotalServiceFeePayable, outputSchedule, totalEarnedFeePerschedule);
                            break;

                        case (int)Constants.FlagValues.AdditionalPayment:
                            //When we goes for all payment according to priority basis
                            NotPrincipalOnlyPayment(outputGrid, scheduleInput, scheduleInput.AdditionalPaymentRecords[additionalIndex].DateIn, scheduleInput.AdditionalPaymentRecords[additionalIndex].AdditionalPayment, additionalIndex, defaultTotalAmountToPay, defaultTotalServiceFeePayable, outputSchedule, totalEarnedFeePerschedule);
                            break;

                        case (int)Constants.FlagValues.Discount:
                            //When we goes only for Discount payment.
                            Discount(outputGrid, scheduleInput, scheduleInput.AdditionalPaymentRecords[additionalIndex].DateIn, additionalIndex, defaultTotalAmountToPay, defaultTotalServiceFeePayable, outputSchedule, totalEarnedFeePerschedule);
                            break;

                        case (int)Constants.FlagValues.NSFFee:
                            //When we goes only for NSF fee payment.
                            NSFFeeAllocation(outputGrid, scheduleInput, scheduleInput.AdditionalPaymentRecords[additionalIndex].DateIn, scheduleInput.AdditionalPaymentRecords[additionalIndex].AdditionalPayment, additionalIndex, defaultTotalAmountToPay, defaultTotalServiceFeePayable, outputSchedule, totalEarnedFeePerschedule);
                            break;

                        case (int)Constants.FlagValues.LateFee:
                            //When we goes only for Late fee payment.
                            LateFeeAllocation(outputGrid, scheduleInput, scheduleInput.AdditionalPaymentRecords[additionalIndex].DateIn, scheduleInput.AdditionalPaymentRecords[additionalIndex].AdditionalPayment, additionalIndex, defaultTotalAmountToPay, defaultTotalServiceFeePayable, outputSchedule, totalEarnedFeePerschedule);
                            break;

                        case (int)Constants.FlagValues.MaintenanceFee:
                            //When we goes only for MaintenanceFee fee payment.
                            MaintenanceFeeAllocation(outputGrid, scheduleInput, scheduleInput.AdditionalPaymentRecords[additionalIndex].DateIn, scheduleInput.AdditionalPaymentRecords[additionalIndex].AdditionalPayment, additionalIndex, defaultTotalAmountToPay, defaultTotalServiceFeePayable, outputSchedule, totalEarnedFeePerschedule);
                            break;

                        case (int)Constants.FlagValues.ManagementFee:
                            //When we goes only for ManagementFee fee payment.
                            ManagementFeeAllocation(outputGrid, scheduleInput, scheduleInput.AdditionalPaymentRecords[additionalIndex].DateIn, scheduleInput.AdditionalPaymentRecords[additionalIndex].AdditionalPayment, additionalIndex, defaultTotalAmountToPay, defaultTotalServiceFeePayable, outputSchedule, totalEarnedFeePerschedule);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        /// <summary>
        /// PrincipalOnlyPayment() method allocate all the additional amount with principal after that all next schedules are allocate amount according to periority basis.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="additionalPaymentlDate"></param>
        /// <param name="addtionalPaymentAmount"></param>
        /// <param name="additionalIndex"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="outputSchedule"></param>
        private static void PrincipalOnlyPayment(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, DateTime additionalPaymentlDate, double addtionalPaymentAmount, int additionalIndex, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable, getScheduleOutput outputSchedule, double totalEarnedFeePerschedule)
        {
            #region Variable declaration
            int indexCount;
            int managementFeeTableIndex = 0;
            int maintenanceFeeTableIndex = 0;
            double managementFeePayable = 0;
            double maintenanceFeePayable = 0;
            int lastManagementFeeChargedIndex = -1;
            int lastMaintenanceFeeChargedIndex = -1;
            StringBuilder sbTracing = new StringBuilder();
            DateTime endDate = Convert.ToDateTime(Constants.DefaultDate);
            DateTime startDate = Convert.ToDateTime(Constants.DefaultDate);
            Boolean FirstOne = false;
            double interestCarryOver = 0;
            double serviceFeeInterestCarryover = 0;
            double interestAccrued = 0;
            double serviceFeeInterest = 0;
            double begnningPrincipal = 0;
            double begnningServiceFee = 0;
            int PaymentDetailIndex = 0;
            double periodicInterestRate = 0;
            double scheduledInterest = 0;
            double scheduledInterestCarryOver = 0;
            int inputGridRowIndex = 1;
            int inputIndex = 0;
            double dailyInterestRate = 0;
            double dailyInterestAmount = 0;
            double paymentAmount = 0;
            int inputGridRow = 0;
            double totalAmountToPay = Round.RoundOffAmount(defaultTotalAmountToPay);
            double totalServiceFeePayable = Round.RoundOffAmount(defaultTotalServiceFeePayable);
            int additionalGridRowIndex = 0;
            double totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
            DateTime prorateFirstScheduleDate = scheduleInput.InputRecords[1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[1].DateIn : scheduleInput.InputRecords[1].EffectiveDate;
            #endregion
            try
            {
                #region Count index where we can add the new schedule for additional payment.
                while (PaymentDetailIndex < outputGrid.Count &&
                      additionalPaymentlDate >= outputGrid[PaymentDetailIndex].PaymentDate)
                {
                    if ((PaymentDetailIndex == outputGrid.FindLastIndex(o => o.PaymentDate == additionalPaymentlDate)) && additionalPaymentlDate == outputGrid[PaymentDetailIndex].PaymentDate)
                    {
                        if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                        {
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() method. Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            additionalGridRowIndex++;
                        }
                        else
                        {

                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            inputGridRowIndex++;

                        }
                        PaymentDetailIndex++;

                        break;
                    }
                    if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() method. Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        additionalGridRowIndex++;
                    }
                    else
                    {

                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        inputGridRowIndex++;

                    }
                    PaymentDetailIndex++;
                }
                #endregion
                FirstOne = true;

                while (PaymentDetailIndex < outputGrid.Count)
                {
                    if (FirstOne)
                    {
                        #region When additional payment schedule created
                        FirstOne = false;
                        if (addtionalPaymentAmount >= outputGrid[PaymentDetailIndex].BeginningPrincipal)
                        {
                            addtionalPaymentAmount = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                        }
                        begnningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                        begnningServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;

                        #region Calculate Priodic Intrest Rate
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }
                            else if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }

                        }
                        if (PaymentDetailIndex == 0)
                        {
                            //Find start date
                            startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                            //Find end date
                            endDate = additionalPaymentlDate;
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[PaymentDetailIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                        }

                        interestAccrued = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                            PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, CreateScheduleForRollingMethod class, and DefaultSchedule() method. Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, CreateScheduleForRollingMethod class, and DefaultSchedule() method. Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        interestAccrued += PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0;
                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false) :
                                             PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        serviceFeeInterest += (PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        // Calculate manatainance and management fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual principal amount
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                            if (totalResidualPrincipal > addtionalPaymentAmount)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - addtionalPaymentAmount);
                            }
                            else
                            {
                                if (totalResidualPrincipal > 0)
                                {
                                    addtionalPaymentAmount = totalResidualPrincipal;
                                    totalResidualPrincipal = 0;
                                }
                                else
                                {
                                    if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                                outputGrid[PaymentDetailIndex - 1].InterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                    {
                                        totalResidualPrincipal = 0;
                                        addtionalPaymentAmount = 0;
                                    }
                                    else
                                    {
                                        totalResidualPrincipal = 0;
                                        addtionalPaymentAmount = 0;
                                        interestAccrued = 0;
                                        dailyInterestAmount = 0;
                                    }
                                }
                            }
                            #endregion
                        }

                        #region Add row for additional Payment
                        if (PaymentDetailIndex > 0)
                        {
                            #region Add Additional payment for principal only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                PaymentDue = 0,
                                TotalPayment = Round.RoundOffAmount(Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue)
                                               + interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue)
                                               + Round.RoundOffAmount(serviceFeeInterest) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue)
                                               + Round.RoundOffAmount(maintenanceFeePayable) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue)
                                               + Round.RoundOffAmount(managementFeePayable) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue)),
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue)),
                                ServiceFeeTotal = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue + serviceFeeInterest + outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue),
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFee = Round.RoundOffAmount(maintenanceFeePayable + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue)),
                                ManagementFee = Round.RoundOffAmount(managementFeePayable + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue)),
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                //Paid amount columns
                                PrincipalPaid = addtionalPaymentAmount,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = addtionalPaymentAmount,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = outputGrid[PaymentDetailIndex - 1].PrincipalPastDue > addtionalPaymentAmount ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue) - addtionalPaymentAmount : 0,
                                InterestPastDue = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                ServiceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterestPastDue = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue),
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFeePastDue = Round.RoundOffAmount(maintenanceFeePayable + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue)),
                                ManagementFeePastDue = Round.RoundOffAmount(managementFeePayable + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue)),
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });

                            #endregion
                        }
                        else
                        {
                            #region Add Additional payment for principal only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = interestAccrued,
                                PrincipalPayment = 0,
                                PaymentDue = 0,
                                TotalPayment = Round.RoundOffAmount(interestAccrued + serviceFeeInterest
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee)
                                               + Round.RoundOffAmount(managementFeePayable) + Round.RoundOffAmount(maintenanceFeePayable)),
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = 0,
                                ServiceFeeInterest = serviceFeeInterest,
                                ServiceFeeTotal = serviceFeeInterest,
                                OriginationFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee) : 0),
                                MaintenanceFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(maintenanceFeePayable) : 0) + scheduleInput.EarnedMaintenanceFee,
                                ManagementFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(managementFeePayable) : 0) + scheduleInput.EarnedManagementFee,
                                SameDayFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee) : 0),
                                NSFFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee) : 0),
                                LateFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee) : 0),
                                //Paid amount columns
                                PrincipalPaid = addtionalPaymentAmount,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = addtionalPaymentAmount,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = 0,
                                InterestPastDue = interestAccrued,
                                ServiceFeePastDue = 0,
                                ServiceFeeInterestPastDue = serviceFeeInterest,
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFeePastDue = Round.RoundOffAmount(maintenanceFeePayable) + scheduleInput.EarnedMaintenanceFee,
                                ManagementFeePastDue = (managementFeePayable) + scheduleInput.EarnedManagementFee,
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee),
                                LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });
                            outputGrid[PaymentDetailIndex + 1].OriginationFee = 0;
                            outputGrid[PaymentDetailIndex + 1].SameDayFee = 0;
                            outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].serviceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].InterestCarryOver = 0;
                            #endregion
                        }
                        #endregion

                        PaymentDetailIndex = PaymentDetailIndex + 1;
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = Round.RoundOffAmount((begnningPrincipal - addtionalPaymentAmount));
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(begnningServiceFee);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                        #region Calculate Priodic Intrest Rate for Next schedule
                        if (string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) && PaymentDetailIndex >= 0)
                        {
                            // Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        }
                        else
                        {
                            // Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            endDate = additionalPaymentlDate;
                            periodicInterestRate = CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                            PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion
                        // Calculate management amd maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                             string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                            PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) : 0;
                        serviceFeeInterestCarryover = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) : 0;

                        #region Calculate Principal payment amount
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                            {
                                // Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                            PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].InterestCarryOver);
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                            if (startindex == 0)
                            {
                                // Find start date
                                startDate = scheduleInput.InputRecords[0].DateIn;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.

                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                            PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = 0;
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                        }
                        #endregion

                        #region Calculate Service fee payment amount
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(scheduledInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                            }
                            else
                            {
                                if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                                {
                                    //Find start date
                                    startDate = outputGrid[startindex].PaymentDate;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.

                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                            PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].AccruedServiceFeeInterestCarryOver);
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                                if (startindex == 0)
                                {
                                    //Find start date
                                    startDate = scheduleInput.InputRecords[0].DateIn;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.

                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                           PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver;
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        #endregion

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                               outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region Calulate interestCarryOver and InterestPayment amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                            }
                            else if ((interestAccrued + interestCarryOver) > totalAmountToPay)
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver) - totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestPayment = totalAmountToPay;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                            }
                            #endregion

                            #region Calulate serviceFeeInterestCarryOver and ServiceFeeInterest amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) > totalServiceFeePayable)
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover) - totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = totalServiceFeePayable;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                            outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;

                            outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                        (interestAccrued + interestCarryOver) : totalAmountToPay) +
                                                                                ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (serviceFeeInterest + serviceFeeInterestCarryover) : totalServiceFeePayable) +
                                                                                ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                      ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                      managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;
                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);

                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest);
                            }

                            outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest);


                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= scheduleInput.EnforcedPrincipal ? scheduleInput.EnforcedPrincipal : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }

                                    outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].PrincipalPayment) : totalAmountToPay) +
                                                                                ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].ServiceFee) : totalServiceFeePayable) +
                                                                                ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                      ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                      managementFeePayable + maintenanceFeePayable + totalEarnedFeePerschedule;
                                    outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    }

                                    outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;
                                }
                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);

                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                        (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                        (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule

                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;

                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;

                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion

                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                             outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                             outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                             outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                             outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }
                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to zero

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    else
                    {
                        #region After additional payment Adjust schedule
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                        double scheduledBegnningPrinciple = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) : 0;

                        #region Calculate Priodic Intrest Rate for Next schedule
                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                            PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, CreateScheduleForRollingMethod class, and DefaultSchedule() method. Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, CreateScheduleForRollingMethod class, and DefaultSchedule() method. Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                            PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver);
                        serviceFeeInterestCarryover = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);

                        //Calculate management and maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;

                            }
                            #endregion
                        }

                        outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                        outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region calculate Principal Amount and Interest Accrued and interestCarryOver amount
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = totalResidualPrincipal;
                            if ((interestAccrued + interestCarryOver) >= totalAmountToPay)
                            {
                                interestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver) - Round.RoundOffAmount(totalAmountToPay));
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount(interestCarryOver);
                                interestAccrued = Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                            }
                            else
                            {
                                if ((interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount(interestAccrued + interestCarryOver);
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                            }
                            #endregion

                            #region calculate serviceFee Amount and ServiceFeeInterest and serviceFeeInterestCarryover amount
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + serviceFeeInterestCarryover + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                                serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);

                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable)
                            {
                                serviceFeeInterestCarryover = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover) - Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount(serviceFeeInterestCarryover);
                                serviceFeeInterest = Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                            }
                            else
                            {
                                if ((serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].BeginningServiceFee) > totalServiceFeePayable)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = scheduledBegnningPrinciple;

                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);

                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = totalAmountToPay + totalServiceFeePayable +
                                                                         ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        outputGrid[PaymentDetailIndex].ManagementFee + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;
                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);


                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest);
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest);
                            }
                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                if (scheduleInput.Residual > 0)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                }
                                outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;

                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                           (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                           (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule
                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;

                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;

                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = (Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount));
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion

                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                               outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                               outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                               outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                               outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }

                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    PaymentDetailIndex = PaymentDetailIndex + 1;
                    inputGridRowIndex++;
                }
                #region Extended schedule if amount are remains past due
                if ((additionalPaymentlDate >= (scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].DateIn : scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate)) && (additionalPaymentlDate >= outputGrid[outputGrid.Count - 1].PaymentDate) && (outputGrid[outputGrid.Count - 1].InterestCarryOver > 0 || outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver > 0
                    || outputGrid[outputGrid.Count - 1].PrincipalPastDue > 0 || outputGrid[outputGrid.Count - 1].InterestPastDue > 0 || outputGrid[outputGrid.Count - 1].ServiceFeePastDue > 0
                    || outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue > 0 || outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue > 0 || outputGrid[outputGrid.Count - 1].ManagementFeePastDue > 0
                    || outputGrid[outputGrid.Count - 1].OriginationFeePastDue > 0 || outputGrid[outputGrid.Count - 1].SameDayFeePastDue > 0 || outputGrid[outputGrid.Count - 1].NSFFeePastDue > 0 || outputGrid[outputGrid.Count - 1].LateFeePastDue > 0))
                {
                    begnningPrincipal = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].BeginningPrincipal - outputGrid[outputGrid.Count - 1].PrincipalPaid);
                    begnningServiceFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].BeginningServiceFee - outputGrid[outputGrid.Count - 1].ServiceFeePaid);

                    #region Calculate Priodic Intrest Rate
                    for (int startindex = outputGrid.Count - 1; startindex >= 0; startindex--)
                    {
                        if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                        {
                            //Find start date
                            startDate = outputGrid[startindex].PaymentDate;
                            //Find end date
                            endDate = additionalPaymentlDate;
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                            break;
                        }
                    }

                    interestAccrued = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, true, false) :
                            PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, true, false);

                    #endregion

                    #region Calculate Daily Interest rate and interest amount 
                    //This variable calculates the daily interest rate for the period.
                    sbTracing.AppendLine("Inside CreateScheduleForRollingMethod class, and DefaultSchedule() method. Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                    "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                    dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                    //This variable calculates the daily interest amount for the period.
                    sbTracing.AppendLine("Inside CreateScheduleForRollingMethod class, and DefaultSchedule() method. Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                        "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                    dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                    dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                    #endregion
                    // Calculate manatainance and management fee
                    sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                    managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalIndex, true, true, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                    sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                    maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalIndex, true, true, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                    interestAccrued = Round.RoundOffAmount(interestAccrued);

                    serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                        string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, true, false) :
                                             PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, true, false);
                    serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                    totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                    if (scheduleInput.Residual > 0)
                    {
                        #region  For the Residual principal amount
                        for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                        {
                            totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                        }
                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                        if (totalResidualPrincipal > addtionalPaymentAmount)
                        {
                            totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - addtionalPaymentAmount);
                        }
                        else
                        {
                            if (totalResidualPrincipal > 0)
                            {
                                addtionalPaymentAmount = totalResidualPrincipal;
                                totalResidualPrincipal = 0;
                            }
                            else
                            {
                                if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex - 1].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                {
                                    totalResidualPrincipal = 0;
                                    addtionalPaymentAmount = 0;
                                }
                                else
                                {
                                    totalResidualPrincipal = 0;
                                    addtionalPaymentAmount = 0;
                                    interestAccrued = 0;
                                    dailyInterestAmount = 0;
                                }

                            }
                        }
                        #endregion
                    }

                    #region Add Additional payment for principal only
                    outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                    {
                        PaymentDate = endDate,
                        BeginningPrincipal = begnningPrincipal,
                        BeginningServiceFee = begnningServiceFee,
                        PeriodicInterestRate = periodicInterestRate,
                        DailyInterestRate = dailyInterestRate,
                        DailyInterestAmount = dailyInterestAmount,
                        PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                        Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                        DueDate = endDate,
                        InterestAccrued = interestAccrued,
                        InterestCarryOver = 0,
                        InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestPastDue),
                        PrincipalPayment = scheduleInput.Residual > 0 ? outputGrid[outputGrid.Count - 1].PrincipalPastDue : Round.RoundOffAmount(begnningPrincipal),
                        PaymentDue = 0,
                        TotalPayment = Round.RoundOffAmount(Round.RoundOffAmount(scheduleInput.Residual > 0 ? addtionalPaymentAmount : begnningPrincipal)
                                       + interestAccrued + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestPastDue)
                                       + Round.RoundOffAmount(begnningServiceFee)
                                       + Round.RoundOffAmount(serviceFeeInterest) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue)
                                       + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].OriginationFeePastDue)
                                       + Round.RoundOffAmount(maintenanceFeePayable) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue)
                                       + Round.RoundOffAmount(managementFeePayable) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ManagementFeePastDue)
                                       + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].SameDayFeePastDue)
                                       + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].NSFFeePastDue)
                                       + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].LateFeePastDue)),
                        AccruedServiceFeeInterest = serviceFeeInterest,
                        AccruedServiceFeeInterestCarryOver = 0,
                        ServiceFee = Round.RoundOffAmount(begnningServiceFee),
                        ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue))),
                        OriginationFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].OriginationFeePastDue),
                        MaintenanceFee = Round.RoundOffAmount(maintenanceFeePayable + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue)),
                        ManagementFee = Round.RoundOffAmount(managementFeePayable + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ManagementFeePastDue)),
                        SameDayFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].SameDayFeePastDue),
                        NSFFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].NSFFeePastDue),
                        LateFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].LateFeePastDue),
                        //Paid amount columns
                        PrincipalPaid = scheduleInput.Residual > 0 ? addtionalPaymentAmount : addtionalPaymentAmount > begnningPrincipal ? begnningPrincipal : addtionalPaymentAmount,
                        InterestPaid = 0,
                        ServiceFeePaid = 0,
                        ServiceFeeInterestPaid = 0,
                        OriginationFeePaid = 0,
                        MaintenanceFeePaid = 0,
                        ManagementFeePaid = 0,
                        SameDayFeePaid = 0,
                        NSFFeePaid = 0,
                        LateFeePaid = 0,
                        TotalPaid = scheduleInput.Residual > 0 ? addtionalPaymentAmount : addtionalPaymentAmount > begnningPrincipal ? begnningPrincipal : addtionalPaymentAmount,
                        //Cumulative Amount paid column
                        CumulativeInterest = 0,
                        CumulativePrincipal = 0,
                        CumulativePayment = 0,
                        CumulativeServiceFee = 0,
                        CumulativeServiceFeeInterest = 0,
                        CumulativeServiceFeeTotal = 0,
                        CumulativeOriginationFee = 0,
                        CumulativeMaintenanceFee = 0,
                        CumulativeManagementFee = 0,
                        CumulativeSameDayFee = 0,
                        CumulativeNSFFee = 0,
                        CumulativeLateFee = 0,
                        CumulativeTotalFees = 0,

                        //Cumulative past due amount columns
                        CumulativePrincipalPastDue = 0,
                        CumulativeInterestPastDue = 0,
                        CumulativeServiceFeePastDue = 0,
                        CumulativeServiceFeeInterestPastDue = 0,
                        CumulativeOriginationFeePastDue = 0,
                        CumulativeMaintenanceFeePastDue = 0,
                        CumulativeManagementFeePastDue = 0,
                        CumulativeSameDayFeePastDue = 0,
                        CumulativeNSFFeePastDue = 0,
                        CumulativeLateFeePastDue = 0,
                        CumulativeTotalPastDue = 0,
                        BucketStatus = ""
                    });
                    outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex].ServiceFee);
                    //Past due amount columns
                    outputGrid[PaymentDetailIndex].PrincipalPastDue = outputGrid[PaymentDetailIndex].PrincipalPayment - outputGrid[PaymentDetailIndex].PrincipalPaid;
                    outputGrid[PaymentDetailIndex].InterestPastDue = outputGrid[PaymentDetailIndex].InterestPayment - outputGrid[PaymentDetailIndex].InterestPaid;
                    outputGrid[PaymentDetailIndex].ServiceFeePastDue = outputGrid[PaymentDetailIndex].ServiceFee - outputGrid[PaymentDetailIndex].ServiceFeePastDue;
                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = outputGrid[PaymentDetailIndex].ServiceFeeInterest - outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid;
                    outputGrid[PaymentDetailIndex].OriginationFeePastDue = outputGrid[PaymentDetailIndex].OriginationFee - outputGrid[PaymentDetailIndex].OriginationFeePaid;
                    outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = outputGrid[PaymentDetailIndex].MaintenanceFee - outputGrid[PaymentDetailIndex].MaintenanceFeePaid;
                    outputGrid[PaymentDetailIndex].ManagementFeePastDue = outputGrid[PaymentDetailIndex].ManagementFee - outputGrid[PaymentDetailIndex].ManagementFeePaid;
                    outputGrid[PaymentDetailIndex].SameDayFeePastDue = outputGrid[PaymentDetailIndex].SameDayFee - outputGrid[PaymentDetailIndex].SameDayFeePaid;
                    outputGrid[PaymentDetailIndex].NSFFeePastDue = outputGrid[PaymentDetailIndex].NSFFee - outputGrid[PaymentDetailIndex].NSFFeePaid;
                    outputGrid[PaymentDetailIndex].LateFeePastDue = outputGrid[PaymentDetailIndex].LateFee - outputGrid[PaymentDetailIndex].LateFeePaid;
                    outputGrid[PaymentDetailIndex].TotalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPastDue + outputGrid[PaymentDetailIndex].InterestPastDue + outputGrid[PaymentDetailIndex].ServiceFeePastDue
                                                                 + outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue + outputGrid[PaymentDetailIndex].MaintenanceFeePastDue + outputGrid[PaymentDetailIndex].ManagementFeePastDue
                                                                 + outputGrid[PaymentDetailIndex].SameDayFeePastDue + outputGrid[PaymentDetailIndex].NSFFeePastDue + outputGrid[PaymentDetailIndex].LateFeePastDue));
                    #endregion
                }
                #endregion
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        /// <summary>
        /// NotPrincipalOnlyPayment() allocate all amount according to periority basis.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="additionalPaymentlDate"></param>
        /// <param name="addtionalPaymentAmount"></param>
        /// <param name="additionalIndex"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="outputSchedule"></param>
        private static void NotPrincipalOnlyPayment(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, DateTime additionalPaymentlDate, double addtionalPaymentAmount, int additionalIndex, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable, getScheduleOutput outputSchedule, double totalEarnedFeePerschedule)
        {
            #region
            int indexCount;
            int managementFeeTableIndex = 0;
            int maintenanceFeeTableIndex = 0;
            double managementFeePayable = 0;
            double maintenanceFeePayable = 0;
            int lastManagementFeeChargedIndex = -1;
            int lastMaintenanceFeeChargedIndex = -1;
            int inputGridRowIndex = 1;
            StringBuilder sbTracing = new StringBuilder();
            DateTime endDate = Convert.ToDateTime(Constants.DefaultDate);
            DateTime startDate = Convert.ToDateTime(Constants.DefaultDate);
            Boolean FirstOne = false;
            double interestCarryOver = 0;
            double serviceFeeInterestCarryover = 0;
            double interestAccrued = 0;
            double serviceFeeInterest = 0;
            double begnningPrincipal = 0;
            double begnningServiceFee = 0;
            int PaymentDetailIndex = 0;
            double periodicInterestRate = 0;
            int inputIndex = 0;
            double scheduledInterest = 0;
            double scheduledInterestCarryOver = 0;
            double dailyInterestRate = 0;
            double dailyInterestAmount = 0;
            double remainningCurrentBegnningPrincipal = 0;
            double remainningCurrentBeginningServiceFee = 0;
            double paymentAmount = 0;
            int inputGridRow = 0;
            double totalAmountToPay = Round.RoundOffAmount(defaultTotalAmountToPay);
            double totalServiceFeePayable = Round.RoundOffAmount(defaultTotalServiceFeePayable);
            int additionalGridRowIndex = 0;
            double totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
            DateTime prorateFirstScheduleDate = scheduleInput.InputRecords[1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[1].DateIn : scheduleInput.InputRecords[1].EffectiveDate;
            #endregion
            try
            {
                #region Count index where we can add the new schedule for additional payment.
                while (PaymentDetailIndex < outputGrid.Count &&
                      additionalPaymentlDate >= outputGrid[PaymentDetailIndex].PaymentDate)
                {
                    if ((PaymentDetailIndex == outputGrid.FindLastIndex(o => o.PaymentDate == additionalPaymentlDate)) && additionalPaymentlDate == outputGrid[PaymentDetailIndex].PaymentDate)
                    {
                        if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                        {
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() method. Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            additionalGridRowIndex++;
                        }
                        else
                        {

                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            inputGridRowIndex++;

                        }
                        PaymentDetailIndex++;
                        break;
                    }
                    if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        additionalGridRowIndex++;
                    }
                    else
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        inputGridRowIndex++;
                    }
                    PaymentDetailIndex++;
                }
                #endregion
                FirstOne = true;
                while (PaymentDetailIndex < outputGrid.Count)
                {
                    if (FirstOne)
                    {
                        #region When additional payment schedule created
                        FirstOne = false;
                        begnningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                        begnningServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;

                        #region Calculate Priodic Intrest Rate
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }
                            else if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }

                        }
                        if (PaymentDetailIndex == 0)
                        {
                            //Find start date
                            startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                            //Find end date
                            endDate = additionalPaymentlDate;
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        interestAccrued += PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0;
                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        serviceFeeInterest += PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0;
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);

                        // Calculate manatainance and management fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }

                        #region Add row for additional Payment
                        if (PaymentDetailIndex > 0)
                        {
                            #region Add Additional payment for not principal only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                PaymentDue = 0,
                                TotalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue)
                                               + interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue)
                                               + serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue)
                                               + Round.RoundOffAmount(maintenanceFeePayable) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue)
                                               + Round.RoundOffAmount(managementFeePayable) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue),
                                ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue + serviceFeeInterest + outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue)),
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFee = Round.RoundOffAmount(maintenanceFeePayable) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue),
                                ManagementFee = Round.RoundOffAmount(managementFeePayable) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue),
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = 0,
                                InterestPastDue = 0,
                                ServiceFeePastDue = 0,
                                ServiceFeeInterestPastDue = 0,
                                OriginationFeePastDue = 0,
                                MaintenanceFeePastDue = 0,
                                ManagementFeePastDue = 0,
                                SameDayFeePastDue = 0,
                                NSFFeePastDue = 0,
                                LateFeePastDue = 0,
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });

                            #endregion
                        }
                        else
                        {
                            #region Add Additional payment for not principal only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = interestAccrued,
                                PrincipalPayment = 0,
                                PaymentDue = 0,
                                TotalPayment = interestAccrued + serviceFeeInterest
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee)
                                               + Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee)
                                               + Round.RoundOffAmount(managementFeePayable)
                                               + Round.RoundOffAmount(maintenanceFeePayable),
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = 0,
                                ServiceFeeInterest = serviceFeeInterest,
                                ServiceFeeTotal = serviceFeeInterest,
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFee = Round.RoundOffAmount(maintenanceFeePayable) + scheduleInput.EarnedMaintenanceFee,
                                ManagementFee = Round.RoundOffAmount(managementFeePayable) + scheduleInput.EarnedManagementFee,
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee),
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee),
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = 0,
                                InterestPastDue = 0,
                                ServiceFeePastDue = 0,
                                ServiceFeeInterestPastDue = 0,
                                OriginationFeePastDue = 0,
                                MaintenanceFeePastDue = 0,
                                ManagementFeePastDue = 0,
                                SameDayFeePastDue = 0,
                                NSFFeePastDue = 0,
                                LateFeePastDue = 0,
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });
                            outputGrid[PaymentDetailIndex + 1].OriginationFee = 0;
                            outputGrid[PaymentDetailIndex + 1].SameDayFee = 0;
                            outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].serviceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].InterestCarryOver = 0;
                            #endregion
                        }
                        #endregion

                        #region Allocation of fund on the basis of priority
                        paymentAmount = Round.RoundOffAmount(addtionalPaymentAmount);
                        inputGridRow = additionalIndex;
                        if (paymentAmount <= 0)
                        {
                            #region
                            outputGrid[PaymentDetailIndex].InterestPaid = 0;
                            outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].InterestPayment));
                            outputGrid[PaymentDetailIndex].CumulativeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].InterestPayment));

                            if (scheduleInput.Residual > 0)
                            {
                                #region  For the Residual principal amount
                                double principalAmount = outputGrid[PaymentDetailIndex].PrincipalPayment;
                                totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                                for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                                {
                                    totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                                }
                                totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                                if (totalResidualPrincipal > principalAmount)
                                {
                                    totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - principalAmount);
                                }
                                else
                                {
                                    if (totalResidualPrincipal > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal;
                                        totalResidualPrincipal = 0;
                                    }
                                    else
                                    {
                                        if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                               outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                        {
                                            totalResidualPrincipal = 0;
                                            outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                        }
                                        else
                                        {
                                            totalResidualPrincipal = 0;
                                            outputGrid[PaymentDetailIndex].InterestAccrued = 0;
                                            outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                            outputGrid[PaymentDetailIndex].DailyInterestAmount = 0;
                                        }
                                    }
                                }

                                #endregion
                            }
                            outputGrid[PaymentDetailIndex].PrincipalPaid = 0;
                            outputGrid[PaymentDetailIndex].PrincipalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPayment));
                            outputGrid[PaymentDetailIndex].CumulativePrincipalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPayment));

                            outputGrid[PaymentDetailIndex].ServiceFeePaid = 0;
                            outputGrid[PaymentDetailIndex].ServiceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee));
                            outputGrid[PaymentDetailIndex].CumulativeServiceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee));

                            outputGrid[PaymentDetailIndex].NSFFeePaid = 0;
                            outputGrid[PaymentDetailIndex].NSFFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].NSFFee));
                            outputGrid[PaymentDetailIndex].CumulativeNSFFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].NSFFee));

                            outputGrid[PaymentDetailIndex].LateFeePaid = 0;
                            outputGrid[PaymentDetailIndex].LateFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].LateFee));
                            outputGrid[PaymentDetailIndex].CumulativeLateFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].LateFee));

                            outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = 0;
                            outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            outputGrid[PaymentDetailIndex].CumulativeServiceFeeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest));

                            outputGrid[PaymentDetailIndex].OriginationFeePaid = 0;
                            outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee));
                            outputGrid[PaymentDetailIndex].CumulativeOriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee));

                            outputGrid[PaymentDetailIndex].ManagementFeePaid = 0;
                            outputGrid[PaymentDetailIndex].ManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee));
                            outputGrid[PaymentDetailIndex].CumulativeManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee));

                            outputGrid[PaymentDetailIndex].MaintenanceFeePaid = 0;
                            outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee));
                            outputGrid[PaymentDetailIndex].CumulativeMaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee));

                            outputGrid[PaymentDetailIndex].SameDayFeePaid = 0;
                            outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee));
                            outputGrid[PaymentDetailIndex].CumulativeSameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee));
                            #endregion
                        }
                        else
                        {
                            #region
                            for (int i = 1; i <= 10; i++)
                            {
                                //Allocate funds to interest amount
                                if (scheduleInput.AdditionalPaymentRecords[inputGridRow].InterestPriority == i)
                                {
                                    #region
                                    double interestAmount = outputGrid[PaymentDetailIndex].InterestPayment;
                                    if (interestAmount <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].InterestPaid = interestAmount;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(interestAmount);
                                        outputGrid[PaymentDetailIndex].InterestPastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativeInterestPastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].InterestPaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount((interestAmount - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativeInterestPastDue = Round.RoundOffAmount((interestAmount - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].InterestPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPaid);
                                    #endregion
                                }

                                //Allocate funds to principal amount
                                else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].PrincipalPriority == i)
                                {
                                    #region
                                    double principalAmount = outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    if (scheduleInput.Residual > 0)
                                    {
                                        #region  For the Residual principal amount
                                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                                        for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                                        {
                                            totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                                        }
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                                        if (totalResidualPrincipal > principalAmount)
                                        {
                                            totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - principalAmount);
                                        }
                                        else
                                        {
                                            if (totalResidualPrincipal > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal;
                                                principalAmount = totalResidualPrincipal;
                                                totalResidualPrincipal = 0;
                                            }
                                            else
                                            {
                                                if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                               outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                                {
                                                    totalResidualPrincipal = 0;
                                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                                }
                                                else
                                                {
                                                    principalAmount = 0;
                                                    totalResidualPrincipal = 0;
                                                    outputGrid[PaymentDetailIndex].InterestAccrued = 0;
                                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                                    outputGrid[PaymentDetailIndex].DailyInterestAmount = 0;
                                                }
                                            }
                                        }

                                        #endregion
                                    }
                                    if (principalAmount <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPaid = principalAmount;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(principalAmount);
                                        outputGrid[PaymentDetailIndex].PrincipalPastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativePrincipalPastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].PrincipalPastDue = Round.RoundOffAmount((principalAmount - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativePrincipalPastDue = Round.RoundOffAmount((principalAmount - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].PrincipalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid);
                                    #endregion
                                }

                                //Allocate funds to Service Fee amount
                                else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].ServiceFeePriority == i)
                                {
                                    double serviceFeeAmount = outputGrid[PaymentDetailIndex].ServiceFee;
                                    if (serviceFeeAmount <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFeePaid = serviceFeeAmount;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(serviceFeeAmount);
                                        outputGrid[PaymentDetailIndex].ServiceFeePastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativeServiceFeePastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFeePaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].ServiceFeePastDue = Round.RoundOffAmount((serviceFeeAmount - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativeServiceFeePastDue = Round.RoundOffAmount((serviceFeeAmount - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].ServiceFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid);
                                }
                                //Allocate funds to NSF Fee amount
                                else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].NSFFeePriority == i)
                                {
                                    double nsfFeeAmount = outputGrid[PaymentDetailIndex].NSFFee;
                                    if (nsfFeeAmount <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].NSFFeePaid = nsfFeeAmount;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(nsfFeeAmount);
                                        outputGrid[PaymentDetailIndex].NSFFeePastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativeNSFFeePastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].NSFFeePaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].NSFFeePastDue = Round.RoundOffAmount((nsfFeeAmount - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativeNSFFeePastDue = Round.RoundOffAmount((nsfFeeAmount - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].NSFFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFeePaid);
                                }
                                //Allocate funds to Late Fee amount
                                else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].LateFeePriority == i)
                                {
                                    double lateFeeAmount = outputGrid[PaymentDetailIndex].LateFee;
                                    if (lateFeeAmount <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].LateFeePaid = lateFeeAmount;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(lateFeeAmount);
                                        outputGrid[PaymentDetailIndex].LateFeePastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativeLateFeePastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].LateFeePaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].LateFeePastDue = Round.RoundOffAmount((lateFeeAmount - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativeLateFeePastDue = Round.RoundOffAmount((lateFeeAmount - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].LateFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFeePaid);
                                }
                                //Allocate funds to Service Fee Interest amount
                                else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].ServiceFeeInterestPriority == i)
                                {
                                    double serviceFeeInterestAmount = outputGrid[PaymentDetailIndex].ServiceFeeInterest;
                                    if (serviceFeeInterestAmount <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = serviceFeeInterestAmount;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(serviceFeeInterestAmount);
                                        outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativeServiceFeeInterestPastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount((serviceFeeInterestAmount - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativeServiceFeeInterestPastDue = Round.RoundOffAmount((serviceFeeInterestAmount - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid);
                                }

                                //Allocate funds to Origination Fee amount
                                else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].OriginationFeePriority == i)
                                {
                                    if (outputGrid[PaymentDetailIndex].OriginationFee <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].OriginationFeePaid = outputGrid[PaymentDetailIndex].OriginationFee;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee);
                                        outputGrid[PaymentDetailIndex].OriginationFeePastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativeOriginationFeePastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].OriginationFeePaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativeOriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].OriginationFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFeePaid);
                                }

                                //Allocate funds to Management Fee amount
                                else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].ManagementFeePriority == i)
                                {
                                    if (outputGrid[PaymentDetailIndex].ManagementFee <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].ManagementFeePaid = outputGrid[PaymentDetailIndex].ManagementFee;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ManagementFee);
                                        outputGrid[PaymentDetailIndex].ManagementFeePastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativeManagementFeePastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].ManagementFeePaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].ManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativeManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].ManagementFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ManagementFeePaid);
                                }

                                //Allocate funds to Maintenance Fee amount
                                else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].MaintenanceFeePriority == i)
                                {
                                    if (outputGrid[PaymentDetailIndex].MaintenanceFee <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].MaintenanceFeePaid = outputGrid[PaymentDetailIndex].MaintenanceFee;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].MaintenanceFee);
                                        outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativeMaintenanceFeePastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].MaintenanceFeePaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativeMaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].MaintenanceFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].MaintenanceFeePaid);
                                }

                                //Allocate funds to Same Day Fee amount
                                else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].SameDayFeePriority == i)
                                {
                                    if (outputGrid[PaymentDetailIndex].SameDayFee <= paymentAmount)
                                    {
                                        outputGrid[PaymentDetailIndex].SameDayFeePaid = outputGrid[PaymentDetailIndex].SameDayFee;
                                        paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee);
                                        outputGrid[PaymentDetailIndex].SameDayFeePastDue = 0;
                                        outputGrid[PaymentDetailIndex].CumulativeSameDayFeePastDue = 0;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].SameDayFeePaid = paymentAmount;
                                        outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee - paymentAmount));
                                        outputGrid[PaymentDetailIndex].CumulativeSameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee - paymentAmount));
                                        paymentAmount = 0;
                                    }
                                    outputGrid[PaymentDetailIndex].SameDayFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFeePaid);
                                }
                            }
                            #endregion
                        }

                        #endregion

                        #region If Payment amount get remains after all priority allocation have done for a schedule
                        remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                        remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                        for (int startindex = 1; startindex <= 10; startindex++)
                        {
                            if (scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalPriority == startindex)
                            {
                                totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                    if (PaymentDetailIndex != outputGrid.Count - 1)
                                    {
                                        outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                        outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                        totalResidualPrincipal = 0;
                                    }
                                    paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;

                                }
                                else
                                {
                                    if (paymentAmount > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                        outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                        paymentAmount = 0;
                                        totalResidualPrincipal = 0;
                                    }
                                }
                            }
                            if (scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeePriority == startindex)
                            {
                                if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                    if (PaymentDetailIndex != outputGrid.Count - 1)
                                    {
                                        outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                        outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                    }
                                    paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                }
                                else
                                {
                                    if (paymentAmount > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                        outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                        paymentAmount = 0;
                                    }
                                }
                            }
                        }
                        #endregion

                        outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid
                                                                 + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid + outputGrid[PaymentDetailIndex].ServiceFeePaid
                                                                 + outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid
                                                                 + outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid
                                                                 + outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid));

                        PaymentDetailIndex = PaymentDetailIndex + 1;
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = (Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal)) - Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].PrincipalPaid))) > 0
                                                                            ? (Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal)) - Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].PrincipalPaid)))
                                                                            : 0;
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) > 0
                                                                             ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePaid))
                                                                             : 0;
                        if (outputGrid[PaymentDetailIndex].BeginningServiceFee == 0)
                        {
                            outputGrid[PaymentDetailIndex].ServiceFee = 0;
                            outputGrid[PaymentDetailIndex].ServiceFeeTotal = 0;

                        }
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);

                        #region Calculate Priodic Intrest Rate for Next schedule
                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }

                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        //Calculate management amd maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) : 0;
                        serviceFeeInterestCarryover = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) : 0;


                        #region Calculate Principal payment amount

                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.

                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].InterestCarryOver);
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                            if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].DateIn;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = 0;
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                        }
                        #endregion

                        #region Calculate Service fee payment amount

                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(scheduledInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                            }
                            else
                            {
                                if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                                {
                                    //Find start date
                                    startDate = outputGrid[startindex].PaymentDate;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].AccruedServiceFeeInterestCarryOver);
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                                if (startindex == 0)
                                {
                                    //Find start date
                                    startDate = scheduleInput.InputRecords[0].DateIn;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver;
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }

                            }
                        }
                        #endregion

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region Calulate interestCarryOver and InterestPayment amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                            }
                            else if ((interestAccrued + interestCarryOver) > totalAmountToPay)
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver) - totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestPayment = totalAmountToPay;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                            }
                            #endregion

                            #region Calulate serviceFeeInterestCarryOver and ServiceFeeInterest amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) > totalServiceFeePayable)
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover) - totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = totalServiceFeePayable;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                            outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                         (interestAccrued + interestCarryOver) : totalAmountToPay) +
                                                                         ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                         (serviceFeeInterest + serviceFeeInterestCarryover) : totalServiceFeePayable) +
                                                                         ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                          ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                          outputGrid[PaymentDetailIndex].ManagementFee + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;

                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);

                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }


                            outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= scheduleInput.EnforcedPrincipal ? scheduleInput.EnforcedPrincipal : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }

                                    outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].PrincipalPayment) : totalAmountToPay) +
                                                                                ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].ServiceFee) : totalServiceFeePayable) +
                                                                                ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + maintenanceFeePayable + totalEarnedFeePerschedule;
                                    outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    }
                                    outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;
                                }
                            }
                            #endregion

                            #region Allocation of fund on the basis of priority
                            inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                           (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                           (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule
                            remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            for (int startindex = 1; startindex <= 10; startindex++)
                            {
                                if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                {
                                    totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                    remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                    if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                        if (PaymentDetailIndex != outputGrid.Count - 1)
                                        {
                                            outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                            outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                            totalResidualPrincipal = 0;
                                        }
                                        paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                    }
                                    else
                                    {
                                        if (paymentAmount > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                            outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                            paymentAmount = 0;
                                            totalResidualPrincipal = 0;
                                        }
                                    }
                                }
                                if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                {
                                    if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                        if (PaymentDetailIndex != outputGrid.Count - 1)
                                        {
                                            outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                            outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                        }
                                        paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                    }
                                    else
                                    {
                                        if (paymentAmount > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                            outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                            paymentAmount = 0;
                                        }
                                    }
                                }
                            }
                            #endregion

                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                              outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                              outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                              outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                              outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }
                        #endregion
                    }
                    else
                    {
                        #region After additional payment Adjust all next schedule
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);

                        double scheduledBegnningPrinciple = (Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal)) - Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].PrincipalPaid))) > 0
                                                                           ? (Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal)) - Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].PrincipalPaid)))
                                                                           : 0;
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = (Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal)) - Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].PrincipalPaid))) > 0
                                                                           ? (Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal)) - Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].PrincipalPaid)))
                                                                           : 0;
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) > 0
                                                                             ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePaid))
                                                                             : 0;
                        if (outputGrid[PaymentDetailIndex].BeginningServiceFee == 0)
                        {
                            outputGrid[PaymentDetailIndex].ServiceFee = 0;
                        }
                        #region Calculate Priodic Intrest Rate for Next schedule
                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        //Calculate management and maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver);
                        serviceFeeInterestCarryover = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver);

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }

                        outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                        outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region calculate Principal Amount and Interest Accrued and interestCarryOver amount
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = totalResidualPrincipal;
                            if ((interestAccrued + interestCarryOver) >= totalAmountToPay)
                            {
                                interestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver)) - Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount(interestCarryOver);
                                interestAccrued = Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                            }
                            else
                            {
                                if ((interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                            }
                            #endregion

                            #region calculate serviceFee Amount and ServiceFeeInterest and serviceFeeInterestCarryover amount
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + serviceFeeInterestCarryover + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                                serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable)
                            {
                                serviceFeeInterestCarryover = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover)) - Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount(serviceFeeInterestCarryover);
                                serviceFeeInterest = Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                            }
                            else
                            {
                                if ((serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].BeginningServiceFee) > totalServiceFeePayable)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = Round.RoundOffAmount(scheduledBegnningPrinciple);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : (outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) : (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue)));
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = totalAmountToPay + totalServiceFeePayable +
                                                                         ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        outputGrid[PaymentDetailIndex].ManagementFee + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;
                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                if (scheduleInput.Residual > 0)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                }
                                outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;

                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                        (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                        (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule

                            remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            for (int startindex = 1; startindex <= 10; startindex++)
                            {
                                if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                {
                                    totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                    remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                    if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                        if (PaymentDetailIndex != outputGrid.Count - 1)
                                        {
                                            outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                            outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                            totalResidualPrincipal = 0;
                                        }
                                        paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                    }
                                    else
                                    {
                                        if (paymentAmount > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                            outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                            paymentAmount = 0;
                                            totalResidualPrincipal = 0;
                                        }
                                    }
                                }
                                if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                {
                                    if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                        if (PaymentDetailIndex != outputGrid.Count - 1)
                                        {
                                            outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                            outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                        }
                                        paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                    }
                                    else
                                    {
                                        if (paymentAmount > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                            outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                            paymentAmount = 0;
                                        }
                                    }
                                }
                            }
                            #endregion
                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                              outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                              outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                              outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                              outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPayment);
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }

                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    PaymentDetailIndex = PaymentDetailIndex + 1;
                    inputGridRowIndex++;
                }
                #region Extended schedule if amount are remains past due
                if ((additionalPaymentlDate >= (scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].DateIn : scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate)) && (additionalPaymentlDate >= outputGrid[outputGrid.Count - 1].PaymentDate) && (outputGrid[outputGrid.Count - 1].InterestCarryOver > 0 || outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver > 0
                   || outputGrid[outputGrid.Count - 1].PrincipalPastDue > 0 || outputGrid[outputGrid.Count - 1].InterestPastDue > 0 || outputGrid[outputGrid.Count - 1].ServiceFeePastDue > 0
                   || outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue > 0 || outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue > 0 || outputGrid[outputGrid.Count - 1].ManagementFeePastDue > 0
                   || outputGrid[outputGrid.Count - 1].OriginationFeePastDue > 0 || outputGrid[outputGrid.Count - 1].SameDayFeePastDue > 0 || outputGrid[outputGrid.Count - 1].NSFFeePastDue > 0 || outputGrid[outputGrid.Count - 1].LateFeePastDue > 0))
                {
                    totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                    begnningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                    begnningServiceFee = outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) : 0;
                    double previousBegnningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                    #region Calculate Priodic Intrest Rate
                    for (int startindex = outputGrid.Count - 1; startindex >= 0; startindex--)
                    {
                        if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                        {
                            //Find start date
                            startDate = outputGrid[startindex].PaymentDate;
                            //Find end date
                            endDate = additionalPaymentlDate;
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                            break;
                        }
                    }
                    interestAccrued = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, true, false);

                    #endregion

                    #region Calculate Daily Interest rate and interest amount 
                    //This variable calculates the daily interest rate for the period.
                    sbTracing.AppendLine("Inside CreateScheduleForRollingMethod class, and DefaultSchedule() method. Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                        "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                    dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                    //This variable calculates the daily interest amount for the period.
                    sbTracing.AppendLine("Inside CreateScheduleForRollingMethod class, and DefaultSchedule() method. Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                        "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                    dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                    dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                    #endregion

                    // Calculate manatainance and management fee
                    sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                    managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalIndex, true, true, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                    sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NotPrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                    maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalIndex, true, true, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                    interestAccrued = Round.RoundOffAmount(interestAccrued);

                    serviceFeeInterest = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, true, false);
                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest));
                    if (scheduleInput.Residual > 0)
                    {
                        #region  For the Residual operation calculate begnning principal amount
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                        {
                            totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                        }
                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                        if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex - 1].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                        {
                            interestAccrued = 0;
                            dailyInterestAmount = 0;
                        }
                        begnningPrincipal = totalResidualPrincipal;
                        #endregion
                    }

                    #region Add Additional payment for not principal only
                    outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                    {
                        PaymentDate = endDate,
                        BeginningPrincipal = previousBegnningPrincipal,
                        BeginningServiceFee = begnningServiceFee,
                        PeriodicInterestRate = periodicInterestRate,
                        DailyInterestRate = dailyInterestRate,
                        DailyInterestAmount = dailyInterestAmount,
                        PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                        Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                        DueDate = endDate,
                        InterestAccrued = interestAccrued,
                        InterestCarryOver = 0,
                        InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestPastDue),
                        PrincipalPayment = Round.RoundOffAmount(begnningPrincipal),
                        PaymentDue = 0,
                        TotalPayment = Round.RoundOffAmount(begnningPrincipal)
                                       + interestAccrued + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestCarryOver)
                                       + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestPastDue)
                                       + Round.RoundOffAmount(begnningServiceFee)
                                       + serviceFeeInterest + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue)
                                       + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].OriginationFeePastDue)
                                       + Round.RoundOffAmount(maintenanceFeePayable) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue)
                                       + Round.RoundOffAmount(managementFeePayable) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ManagementFeePastDue)
                                       + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].SameDayFeePastDue)
                                       + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].NSFFeePastDue)
                                       + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].LateFeePastDue),
                        AccruedServiceFeeInterest = serviceFeeInterest,
                        AccruedServiceFeeInterestCarryOver = 0,
                        ServiceFee = Round.RoundOffAmount(begnningServiceFee),
                        ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue),
                        OriginationFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].OriginationFeePastDue),
                        MaintenanceFee = Round.RoundOffAmount(maintenanceFeePayable) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue),
                        ManagementFee = Round.RoundOffAmount(managementFeePayable) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ManagementFeePastDue),
                        SameDayFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].SameDayFeePastDue),
                        NSFFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].NSFFeePastDue),
                        LateFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].LateFeePastDue),
                        //Paid amount columns
                        PrincipalPaid = 0,
                        InterestPaid = 0,
                        ServiceFeePaid = 0,
                        ServiceFeeInterestPaid = 0,
                        OriginationFeePaid = 0,
                        MaintenanceFeePaid = 0,
                        ManagementFeePaid = 0,
                        SameDayFeePaid = 0,
                        NSFFeePaid = 0,
                        LateFeePaid = 0,
                        TotalPaid = 0,
                        //Cumulative Amount paid column
                        CumulativeInterest = 0,
                        CumulativePrincipal = 0,
                        CumulativePayment = 0,
                        CumulativeServiceFee = 0,
                        CumulativeServiceFeeInterest = 0,
                        CumulativeServiceFeeTotal = 0,
                        CumulativeOriginationFee = 0,
                        CumulativeMaintenanceFee = 0,
                        CumulativeManagementFee = 0,
                        CumulativeSameDayFee = 0,
                        CumulativeNSFFee = 0,
                        CumulativeLateFee = 0,
                        CumulativeTotalFees = 0,
                        //Past due amount columns
                        PrincipalPastDue = 0,
                        InterestPastDue = 0,
                        ServiceFeePastDue = 0,
                        ServiceFeeInterestPastDue = 0,
                        OriginationFeePastDue = 0,
                        MaintenanceFeePastDue = 0,
                        ManagementFeePastDue = 0,
                        SameDayFeePastDue = 0,
                        NSFFeePastDue = 0,
                        LateFeePastDue = 0,
                        TotalPastDue = 0,
                        //Cumulative past due amount columns
                        CumulativePrincipalPastDue = 0,
                        CumulativeInterestPastDue = 0,
                        CumulativeServiceFeePastDue = 0,
                        CumulativeServiceFeeInterestPastDue = 0,
                        CumulativeOriginationFeePastDue = 0,
                        CumulativeMaintenanceFeePastDue = 0,
                        CumulativeManagementFeePastDue = 0,
                        CumulativeSameDayFeePastDue = 0,
                        CumulativeNSFFeePastDue = 0,
                        CumulativeLateFeePastDue = 0,
                        CumulativeTotalPastDue = 0,
                        BucketStatus = ""
                    });
                    outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex].ServiceFee));
                    #endregion

                    #region Allocation of fund on the basis of priority
                    paymentAmount = Round.RoundOffAmount(addtionalPaymentAmount);
                    inputGridRow = additionalIndex;
                    if (paymentAmount <= 0)
                    {
                        #region
                        outputGrid[PaymentDetailIndex].InterestPaid = 0;
                        outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].InterestPayment));
                        outputGrid[PaymentDetailIndex].CumulativeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].InterestPayment));

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual principal amount
                            double principalAmount = outputGrid[PaymentDetailIndex].PrincipalPayment;
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                            if (totalResidualPrincipal > principalAmount)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - principalAmount);
                            }
                            else
                            {
                                if (totalResidualPrincipal > 0)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal;
                                    totalResidualPrincipal = 0;
                                }
                                else
                                {
                                    if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                    {
                                        totalResidualPrincipal = 0;
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                    }
                                    else
                                    {
                                        totalResidualPrincipal = 0;
                                        outputGrid[PaymentDetailIndex].InterestAccrued = 0;
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                        outputGrid[PaymentDetailIndex].DailyInterestAmount = 0;
                                    }
                                }
                            }

                            #endregion
                        }
                        outputGrid[PaymentDetailIndex].PrincipalPaid = 0;
                        outputGrid[PaymentDetailIndex].PrincipalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPayment));
                        outputGrid[PaymentDetailIndex].CumulativePrincipalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPayment));

                        outputGrid[PaymentDetailIndex].ServiceFeePaid = 0;
                        outputGrid[PaymentDetailIndex].ServiceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee));
                        outputGrid[PaymentDetailIndex].CumulativeServiceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee));

                        outputGrid[PaymentDetailIndex].NSFFeePaid = 0;
                        outputGrid[PaymentDetailIndex].NSFFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].NSFFee));
                        outputGrid[PaymentDetailIndex].CumulativeNSFFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].NSFFee));

                        outputGrid[PaymentDetailIndex].LateFeePaid = 0;
                        outputGrid[PaymentDetailIndex].LateFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].LateFee));
                        outputGrid[PaymentDetailIndex].CumulativeLateFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].LateFee));

                        outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = 0;
                        outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                        outputGrid[PaymentDetailIndex].CumulativeServiceFeeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest));

                        outputGrid[PaymentDetailIndex].OriginationFeePaid = 0;
                        outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee));
                        outputGrid[PaymentDetailIndex].CumulativeOriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee));

                        outputGrid[PaymentDetailIndex].ManagementFeePaid = 0;
                        outputGrid[PaymentDetailIndex].ManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee));
                        outputGrid[PaymentDetailIndex].CumulativeManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee));

                        outputGrid[PaymentDetailIndex].MaintenanceFeePaid = 0;
                        outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee));
                        outputGrid[PaymentDetailIndex].CumulativeMaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee));

                        outputGrid[PaymentDetailIndex].SameDayFeePaid = 0;
                        outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee));
                        outputGrid[PaymentDetailIndex].CumulativeSameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee));
                        #endregion
                    }
                    else
                    {
                        #region
                        for (int i = 1; i <= 10; i++)
                        {
                            //Allocate funds to interest amount
                            if (scheduleInput.AdditionalPaymentRecords[inputGridRow].InterestPriority == i)
                            {
                                #region
                                double interestAmount = outputGrid[PaymentDetailIndex].InterestPayment;
                                if (interestAmount <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].InterestPaid = interestAmount;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(interestAmount);
                                    outputGrid[PaymentDetailIndex].InterestPastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativeInterestPastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].InterestPaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount((interestAmount - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativeInterestPastDue = Round.RoundOffAmount((interestAmount - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].InterestPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPaid);
                                #endregion
                            }

                            //Allocate funds to principal amount
                            else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].PrincipalPriority == i)
                            {
                                #region
                                double principalAmount = outputGrid[PaymentDetailIndex].PrincipalPayment;
                                if (scheduleInput.Residual > 0)
                                {
                                    #region  For the Residual principal amount
                                    totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                                    for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                                    {
                                        totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                                    }
                                    totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                    if (totalResidualPrincipal > principalAmount)
                                    {
                                        totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - principalAmount);
                                    }
                                    else
                                    {
                                        if (totalResidualPrincipal > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal;
                                            principalAmount = totalResidualPrincipal;
                                            totalResidualPrincipal = 0;
                                        }
                                        else
                                        {
                                            if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                            {
                                                totalResidualPrincipal = 0;
                                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                            }
                                            else
                                            {
                                                principalAmount = 0;
                                                totalResidualPrincipal = 0;
                                                outputGrid[PaymentDetailIndex].InterestAccrued = 0;
                                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                                outputGrid[PaymentDetailIndex].DailyInterestAmount = 0;
                                            }
                                        }
                                    }
                                    #endregion
                                }
                                if (principalAmount <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPaid = principalAmount;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(principalAmount);
                                    outputGrid[PaymentDetailIndex].PrincipalPastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativePrincipalPastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].PrincipalPastDue = Round.RoundOffAmount((principalAmount - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativePrincipalPastDue = Round.RoundOffAmount((principalAmount - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].PrincipalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid);
                                #endregion
                            }

                            //Allocate funds to Service Fee amount
                            else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].ServiceFeePriority == i)
                            {
                                double serviceFeeAmount = outputGrid[PaymentDetailIndex].ServiceFee;
                                if (serviceFeeAmount <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFeePaid = serviceFeeAmount;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(serviceFeeAmount);
                                    outputGrid[PaymentDetailIndex].ServiceFeePastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativeServiceFeePastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFeePaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].ServiceFeePastDue = Round.RoundOffAmount((serviceFeeAmount - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativeServiceFeePastDue = Round.RoundOffAmount((serviceFeeAmount - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].ServiceFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid);
                            }
                            //Allocate funds to NSF Fee amount
                            else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].NSFFeePriority == i)
                            {
                                double nsfFeeAmount = outputGrid[PaymentDetailIndex].NSFFee;
                                if (nsfFeeAmount <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].NSFFeePaid = nsfFeeAmount;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(nsfFeeAmount);
                                    outputGrid[PaymentDetailIndex].NSFFeePastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativeNSFFeePastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].NSFFeePaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].NSFFeePastDue = Round.RoundOffAmount((nsfFeeAmount - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativeNSFFeePastDue = Round.RoundOffAmount((nsfFeeAmount - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].NSFFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFeePaid);
                            }
                            //Allocate funds to Late Fee amount
                            else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].LateFeePriority == i)
                            {
                                double lateFeeAmount = outputGrid[PaymentDetailIndex].LateFee;
                                if (lateFeeAmount <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].LateFeePaid = lateFeeAmount;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(lateFeeAmount);
                                    outputGrid[PaymentDetailIndex].LateFeePastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativeLateFeePastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].LateFeePaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].LateFeePastDue = Round.RoundOffAmount((lateFeeAmount - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativeLateFeePastDue = Round.RoundOffAmount((lateFeeAmount - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].LateFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFeePaid);
                            }
                            //Allocate funds to Service Fee Interest amount
                            else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].ServiceFeeInterestPriority == i)
                            {
                                double serviceFeeInterestAmount = outputGrid[PaymentDetailIndex].ServiceFeeInterest;
                                if (serviceFeeInterestAmount <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = serviceFeeInterestAmount;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(serviceFeeInterestAmount);
                                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativeServiceFeeInterestPastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount((serviceFeeInterestAmount - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativeServiceFeeInterestPastDue = Round.RoundOffAmount((serviceFeeInterestAmount - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid);
                            }

                            //Allocate funds to Origination Fee amount
                            else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].OriginationFeePriority == i)
                            {
                                if (outputGrid[PaymentDetailIndex].OriginationFee <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].OriginationFeePaid = outputGrid[PaymentDetailIndex].OriginationFee;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee);
                                    outputGrid[PaymentDetailIndex].OriginationFeePastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativeOriginationFeePastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].OriginationFeePaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativeOriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].OriginationFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFeePaid);
                            }

                            //Allocate funds to Management Fee amount
                            else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].ManagementFeePriority == i)
                            {
                                if (outputGrid[PaymentDetailIndex].ManagementFee <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].ManagementFeePaid = outputGrid[PaymentDetailIndex].ManagementFee;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ManagementFee);
                                    outputGrid[PaymentDetailIndex].ManagementFeePastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativeManagementFeePastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ManagementFeePaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].ManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativeManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].ManagementFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ManagementFeePaid);
                            }

                            //Allocate funds to Maintenance Fee amount
                            else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].MaintenanceFeePriority == i)
                            {
                                if (outputGrid[PaymentDetailIndex].MaintenanceFee <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].MaintenanceFeePaid = outputGrid[PaymentDetailIndex].MaintenanceFee;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].MaintenanceFee);
                                    outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativeMaintenanceFeePastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].MaintenanceFeePaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativeMaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].MaintenanceFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].MaintenanceFeePaid);
                            }

                            //Allocate funds to Same Day Fee amount
                            else if (scheduleInput.AdditionalPaymentRecords[inputGridRow].SameDayFeePriority == i)
                            {
                                if (outputGrid[PaymentDetailIndex].SameDayFee <= paymentAmount)
                                {
                                    outputGrid[PaymentDetailIndex].SameDayFeePaid = outputGrid[PaymentDetailIndex].SameDayFee;
                                    paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee);
                                    outputGrid[PaymentDetailIndex].SameDayFeePastDue = 0;
                                    outputGrid[PaymentDetailIndex].CumulativeSameDayFeePastDue = 0;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].SameDayFeePaid = paymentAmount;
                                    outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee - paymentAmount));
                                    outputGrid[PaymentDetailIndex].CumulativeSameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee - paymentAmount));
                                    paymentAmount = 0;
                                }
                                outputGrid[PaymentDetailIndex].SameDayFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFeePaid);
                            }
                        }
                        #endregion
                    }

                    #endregion

                    #region If Payment amount get remains after all priority allocation have done for a schedule
                    remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                    remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                    for (int startindex = 1; startindex <= 10; startindex++)
                    {
                        if (scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalPriority == startindex)
                        {
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                            if (paymentAmount >= remainningCurrentBegnningPrincipal)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                totalResidualPrincipal = 0;

                            }
                            else
                            {
                                if (paymentAmount > 0)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                    paymentAmount = 0;
                                    totalResidualPrincipal = 0;
                                }
                            }
                        }
                        if (scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeePriority == startindex)
                        {
                            if (paymentAmount >= remainningCurrentBeginningServiceFee)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                            }
                            else
                            {
                                if (paymentAmount > 0)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                    paymentAmount = 0;
                                }
                            }
                        }
                    }
                    #endregion

                    outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid
                                                             + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid + outputGrid[PaymentDetailIndex].ServiceFeePaid
                                                             + outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid
                                                             + outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid
                                                             + outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid));
                }
                #endregion
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        /// <summary>
        /// NSFFeeAllocation() allocate the NSF fee amount after that reschedule all amount after addition of NSF fee schedules.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="additionalPaymentlDate"></param>
        /// <param name="addtionalPaymentAmount"></param>
        /// <param name="additionalIndex"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="outputSchedule"></param>
        private static void NSFFeeAllocation(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, DateTime additionalPaymentlDate, double addtionalPaymentAmount, int additionalIndex, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable, getScheduleOutput outputSchedule, double totalEarnedFeePerschedule)
        {
            #region
            int indexCount;
            int managementFeeTableIndex = 0;
            int maintenanceFeeTableIndex = 0;
            double managementFeePayable = 0;
            double maintenanceFeePayable = 0;
            int lastManagementFeeChargedIndex = -1;
            int lastMaintenanceFeeChargedIndex = -1;
            StringBuilder sbTracing = new StringBuilder();
            DateTime endDate = Convert.ToDateTime(Constants.DefaultDate);
            DateTime startDate = Convert.ToDateTime(Constants.DefaultDate);
            Boolean FirstOne = false;
            double interestCarryOver = 0;
            double serviceFeeInterestCarryover = 0;
            double interestAccrued = 0;
            double serviceFeeInterest = 0;
            double begnningPrincipal = 0;
            double begnningServiceFee = 0;
            int PaymentDetailIndex = 0;
            double periodicInterestRate = 0;
            double scheduledInterest = 0;
            double scheduledInterestCarryOver = 0;
            int inputIndex = 0;
            int count = 0;
            int inputGridRowIndex = 1;
            int inputGridRow = 0;
            double paymentAmount = 0;
            double dailyInterestRate = 0;
            double dailyInterestAmount = 0;
            int additionalGridRowIndex = 0;
            double totalAmountToPay = Round.RoundOffAmount(defaultTotalAmountToPay);
            double totalServiceFeePayable = Round.RoundOffAmount(defaultTotalServiceFeePayable);
            double totalResidualPrincipal = 0;
            DateTime prorateFirstScheduleDate = scheduleInput.InputRecords[1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[1].DateIn : scheduleInput.InputRecords[1].EffectiveDate;
            #endregion
            try
            {
                #region Count index where we can add the new schedule for additional payment.
                while (PaymentDetailIndex < outputGrid.Count &&
                      additionalPaymentlDate >= outputGrid[PaymentDetailIndex].PaymentDate)
                {
                    if ((PaymentDetailIndex == outputGrid.FindLastIndex(o => o.PaymentDate == additionalPaymentlDate)) && additionalPaymentlDate == outputGrid[PaymentDetailIndex].PaymentDate)
                    {
                        if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                        {
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() method. Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            additionalGridRowIndex++;
                        }
                        else
                        {

                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            inputGridRowIndex++;

                        }
                        PaymentDetailIndex++;
                        break;
                    }
                    if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        additionalGridRowIndex++;
                    }
                    else
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        inputGridRowIndex++;
                    }
                    PaymentDetailIndex++;
                }
                #endregion
                FirstOne = true;
                while (PaymentDetailIndex < outputGrid.Count)
                {
                    if (FirstOne)
                    {
                        #region When additional payment schedule created
                        FirstOne = false;
                        begnningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                        begnningServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;

                        #region Calculate Priodic Intrest Rate
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }
                            else if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }

                        }
                        if (PaymentDetailIndex == 0)
                        {
                            //Find start date
                            startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                            //Find end date
                            endDate = additionalPaymentlDate;
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion
                        interestAccrued += PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0;
                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false);
                        serviceFeeInterest += PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0;
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }

                        #region Add row for additional Payment
                        if (PaymentDetailIndex > 0)
                        {
                            #region Add Additional payment for NSF Fee only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue))),
                                ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue + serviceFeeInterest + outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue)),
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue),
                                ManagementFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue),
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFee = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].NSFFeePastDue)),
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                InterestPastDue = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                ServiceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterestPastDue = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue),
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue),
                                ManagementFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue),
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFeePastDue = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].NSFFeePastDue)),
                                LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });

                            #endregion
                        }
                        else
                        {
                            #region Add Additional payment for NSF Fee only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = interestAccrued,
                                PrincipalPayment = 0,
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = 0,
                                ServiceFeeInterest = serviceFeeInterest,
                                ServiceFeeTotal = serviceFeeInterest,
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(maintenanceFeePayable) : 0) + scheduleInput.EarnedMaintenanceFee,
                                ManagementFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(managementFeePayable) : 0) + scheduleInput.EarnedManagementFee,
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFee = PaymentDetailIndex == 0 ? (addtionalPaymentAmount + scheduleInput.EarnedNSFFee) : 0,
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee),
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = 0,
                                InterestPastDue = interestAccrued,
                                ServiceFeePastDue = 0,
                                ServiceFeeInterestPastDue = serviceFeeInterest,
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFeePastDue = maintenanceFeePayable + scheduleInput.EarnedMaintenanceFee,
                                ManagementFeePastDue = managementFeePayable + scheduleInput.EarnedManagementFee,
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFeePastDue = PaymentDetailIndex == 0 ? (addtionalPaymentAmount + scheduleInput.EarnedNSFFee) : 0,
                                LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });
                            outputGrid[PaymentDetailIndex + 1].OriginationFee = 0;
                            outputGrid[PaymentDetailIndex + 1].SameDayFee = 0;
                            outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].serviceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].InterestCarryOver = 0;
                            #endregion
                        }
                        #endregion

                        PaymentDetailIndex = PaymentDetailIndex + 1;
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = Round.RoundOffAmount(begnningPrincipal);
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(begnningServiceFee);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);

                        #region Calculate Priodic Intrest Rate for Next schedule

                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }

                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion
                        //Calculate management amd maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);

                        interestCarryOver = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) : 0;
                        serviceFeeInterestCarryover = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) : 0;
                        #region Calculate Principal payment amount
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.

                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].InterestCarryOver);
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                            if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].DateIn;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.

                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = 0;
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                        }
                        #endregion

                        #region Calculate Service fee payment amount
                        count = 0;
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(scheduledInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                            }
                            else
                            {
                                if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                                {
                                    //Find start date
                                    startDate = outputGrid[startindex].PaymentDate;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].AccruedServiceFeeInterestCarryOver);
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    count++;
                                    break;
                                }
                                if (count == 0 && startindex == 0)
                                {
                                    //Find start date
                                    startDate = scheduleInput.InputRecords[0].DateIn;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);

                                    scheduledInterestCarryOver = outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver;
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        #endregion

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region Calulate interestCarryOver and InterestPayment amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                            }
                            else if ((interestAccrued + interestCarryOver) > totalAmountToPay)
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver) - totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestPayment = totalAmountToPay;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                            }
                            #endregion

                            #region Calulate serviceFeeInterestCarryOver and ServiceFeeInterest amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) > totalServiceFeePayable)
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover) - totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = totalServiceFeePayable;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                            outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                       (interestAccrued + interestCarryOver) : totalAmountToPay) +
                                                                       ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                       (serviceFeeInterest + serviceFeeInterestCarryover) : totalServiceFeePayable) +
                                                                       ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;

                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);

                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }

                            outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= scheduleInput.EnforcedPrincipal ? scheduleInput.EnforcedPrincipal : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }

                                    outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].PrincipalPayment) : totalAmountToPay) +
                                                                                ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].ServiceFee) : totalServiceFeePayable) +
                                                                                 ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + maintenanceFeePayable + totalEarnedFeePerschedule;
                                    outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    }
                                    outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;
                                }
                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                            (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                            (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule

                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                            remainningCurrentBegnningPrincipal = 0;
                                            totalResidualPrincipal = 0;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                            remainningCurrentBeginningServiceFee = 0;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion

                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                               outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                               outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                               outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                               outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }
                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    else
                    {
                        #region After additional payment Adjust schedule
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);

                        double scheduledBegnningPrinciple = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) : 0;

                        #region Calculate Priodic Intrest Rate for Next schedule

                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver);
                        serviceFeeInterestCarryover = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver);

                        //Calculate management and maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and NSFFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }

                            #endregion
                        }
                        outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                        outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region calculate Principal Amount and Interest Accrued and interestCarryOver amount
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = totalResidualPrincipal;
                            if ((interestAccrued + interestCarryOver) >= totalAmountToPay)
                            {
                                interestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver)) - Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount(interestCarryOver);
                                interestAccrued = Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                            }
                            else
                            {
                                if ((interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                            }
                            #endregion

                            #region calculate serviceFee Amount and ServiceFeeInterest and serviceFeeInterestCarryover amount
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + serviceFeeInterestCarryover + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                                serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));

                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable)
                            {
                                serviceFeeInterestCarryover = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover)) - Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount(serviceFeeInterestCarryover);
                                serviceFeeInterest = Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                            }
                            else
                            {
                                if ((serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].BeginningServiceFee) > totalServiceFeePayable)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = scheduledBegnningPrinciple;

                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = totalAmountToPay + totalServiceFeePayable +
                                                                         ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;
                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                if (scheduleInput.Residual > 0)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                }
                                outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;

                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                           (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                           (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule
                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;

                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion

                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                              outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                              outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                              outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                              outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }
                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro
                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    PaymentDetailIndex = PaymentDetailIndex + 1;
                    inputGridRowIndex++;
                }
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        /// <summary>
        /// LatefeeAllocation() allocate the late fee amount after that reschedule all amount after addition of late fee schedules.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="additionalPaymentlDate"></param>
        /// <param name="addtionalPaymentAmount"></param>
        /// <param name="additionalIndex"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="outputSchedule"></param>
        private static void LateFeeAllocation(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, DateTime additionalPaymentlDate, double addtionalPaymentAmount, int additionalIndex, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable, getScheduleOutput outputSchedule, double totalEarnedFeePerschedule)
        {
            #region
            int indexCount;
            int managementFeeTableIndex = 0;
            int maintenanceFeeTableIndex = 0;
            double managementFeePayable = 0;
            double maintenanceFeePayable = 0;
            int lastManagementFeeChargedIndex = -1;
            int lastMaintenanceFeeChargedIndex = -1;
            StringBuilder sbTracing = new StringBuilder();
            DateTime endDate = Convert.ToDateTime(Constants.DefaultDate);
            DateTime startDate = Convert.ToDateTime(Constants.DefaultDate);
            Boolean FirstOne = false;
            double interestCarryOver = 0;
            double serviceFeeInterestCarryover = 0;
            double interestAccrued = 0;
            double serviceFeeInterest = 0;
            double begnningPrincipal = 0;
            double begnningServiceFee = 0;
            int PaymentDetailIndex = 0;
            double periodicInterestRate = 0;
            double scheduledInterest = 0;
            double scheduledInterestCarryOver = 0;
            double paymentAmount = 0;
            int inputGridRow = 0;
            int inputIndex = 0;
            int inputGridRowIndex = 1;
            double dailyInterestRate = 0;
            double dailyInterestAmount = 0;
            int additionalGridRowIndex = 0;
            double totalAmountToPay = Round.RoundOffAmount(defaultTotalAmountToPay);
            double totalServiceFeePayable = Round.RoundOffAmount(defaultTotalServiceFeePayable);
            double totalResidualPrincipal = 0;
            DateTime prorateFirstScheduleDate = scheduleInput.InputRecords[1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[1].DateIn : scheduleInput.InputRecords[1].EffectiveDate;
            #endregion
            try
            {
                #region Count index where we can add the new schedule for additional payment.
                while (PaymentDetailIndex < outputGrid.Count &&
                      additionalPaymentlDate >= outputGrid[PaymentDetailIndex].PaymentDate)
                {
                    if ((PaymentDetailIndex == outputGrid.FindLastIndex(o => o.PaymentDate == additionalPaymentlDate)) && additionalPaymentlDate == outputGrid[PaymentDetailIndex].PaymentDate)
                    {
                        if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                        {
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() method. Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            additionalGridRowIndex++;
                        }
                        else
                        {

                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            inputGridRowIndex++;

                        }
                        PaymentDetailIndex++;
                        break;
                    }
                    if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        additionalGridRowIndex++;
                    }
                    else
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        inputGridRowIndex++;
                    }
                    PaymentDetailIndex++;
                }
                #endregion
                FirstOne = true;
                while (PaymentDetailIndex < outputGrid.Count)
                {
                    if (FirstOne)
                    {
                        #region When additional payment schedule created
                        FirstOne = false;
                        begnningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                        begnningServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;

                        #region Calculate Priodic Intrest Rate
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }
                            else if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }

                        }
                        if (PaymentDetailIndex == 0)
                        {
                            //Find start date
                            startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                            //Find end date
                            endDate = additionalPaymentlDate;
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false);

                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion
                        interestAccrued += PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0;
                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false);
                        serviceFeeInterest += PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0;
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }

                        #region Add row for additional Payment
                        if (PaymentDetailIndex > 0)
                        {
                            #region Add Additional payment for Late Fee only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue))),
                                ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue + serviceFeeInterest + outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue)),
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue),
                                ManagementFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue),
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFee = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].LateFeePastDue)),
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                InterestPastDue = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                ServiceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterestPastDue = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue),
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue),
                                ManagementFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue),
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFeePastDue = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].LateFeePastDue)),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });

                            #endregion
                        }
                        else
                        {
                            #region Add Additional payment for Late fee only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = interestAccrued,
                                PrincipalPayment = 0,
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = 0,
                                ServiceFeeInterest = serviceFeeInterest,
                                ServiceFeeTotal = serviceFeeInterest,
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(maintenanceFeePayable) : 0) + scheduleInput.EarnedMaintenanceFee,
                                ManagementFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(managementFeePayable) : 0) + scheduleInput.EarnedManagementFee,
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee),
                                LateFee = PaymentDetailIndex == 0 ? (addtionalPaymentAmount + scheduleInput.EarnedLateFee) : 0,
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = 0,
                                InterestPastDue = interestAccrued,
                                ServiceFeePastDue = 0,
                                ServiceFeeInterestPastDue = serviceFeeInterest,
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFeePastDue = maintenanceFeePayable + scheduleInput.EarnedMaintenanceFee,
                                ManagementFeePastDue = managementFeePayable + scheduleInput.EarnedManagementFee,
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee),
                                LateFeePastDue = PaymentDetailIndex == 0 ? (addtionalPaymentAmount + scheduleInput.EarnedLateFee) : 0,
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });
                            outputGrid[PaymentDetailIndex + 1].OriginationFee = 0;
                            outputGrid[PaymentDetailIndex + 1].SameDayFee = 0;
                            outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].serviceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].InterestCarryOver = 0;
                            #endregion
                        }
                        #endregion

                        PaymentDetailIndex = PaymentDetailIndex + 1;
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = Round.RoundOffAmount(begnningPrincipal);
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(begnningServiceFee);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);

                        #region Calculate Priodic Intrest Rate for Next schedule
                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion
                        // Calculate management amd maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);

                        interestCarryOver = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) : 0;
                        serviceFeeInterestCarryover = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) : 0;
                        #region Calculate Principal payment amount

                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //FInd end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].InterestCarryOver);
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                            if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].DateIn;
                                //FInd end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = 0;
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                        }
                        #endregion

                        #region Calculate Service fee payment amount
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(scheduledInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                            }
                            else
                            {
                                if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                                {
                                    //Find start date
                                    startDate = outputGrid[startindex].PaymentDate;
                                    //FInd end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].AccruedServiceFeeInterestCarryOver);
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                                if (startindex == 0)
                                {
                                    //Find start date
                                    startDate = scheduleInput.InputRecords[0].DateIn;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver;
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        #endregion

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region Calulate interestCarryOver and InterestPayment amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                            }
                            else if ((interestAccrued + interestCarryOver) > totalAmountToPay)
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver) - totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestPayment = totalAmountToPay;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                            }
                            #endregion

                            #region Calulate serviceFeeInterestCarryOver and ServiceFeeInterest amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) > totalServiceFeePayable)
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover) - totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = totalServiceFeePayable;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                            outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                         (interestAccrued + interestCarryOver) : totalAmountToPay) +
                                                                         ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                         (serviceFeeInterest + serviceFeeInterestCarryover) : totalServiceFeePayable) +
                                                                         ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                           ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                           managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;

                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }

                            outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= scheduleInput.EnforcedPrincipal ? scheduleInput.EnforcedPrincipal : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }

                                    outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].PrincipalPayment) : totalAmountToPay) +
                                                                                ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].ServiceFee) : totalServiceFeePayable) +
                                                                                 ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + maintenanceFeePayable + totalEarnedFeePerschedule;
                                    outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    }
                                    outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;
                                }
                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                          (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                          (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule
                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion

                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                               outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                               outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                               outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                               outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }

                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    else
                    {
                        #region After additional payment Adjust schedule
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);

                        double scheduledBegnningPrinciple = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) : 0;

                        #region Calculate Priodic Intrest Rate for Next schedule

                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver);
                        serviceFeeInterestCarryover = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver);


                        //Calculate management and maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and LateFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }

                            #endregion
                        }

                        outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                        outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region calculate Principal Amount and Interest Accrued and interestCarryOver amount
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = totalResidualPrincipal;
                            if ((interestAccrued + interestCarryOver) >= totalAmountToPay)
                            {
                                interestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver)) - Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount(interestCarryOver);
                                interestAccrued = Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                            }
                            else
                            {
                                if ((interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                            }
                            #endregion

                            #region calculate serviceFee Amount and ServiceFeeInterest and serviceFeeInterestCarryover amount
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + serviceFeeInterestCarryover + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                                serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));

                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable)
                            {
                                serviceFeeInterestCarryover = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover)) - Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount(serviceFeeInterestCarryover);
                                serviceFeeInterest = Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                            }
                            else
                            {
                                if ((serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].BeginningServiceFee) > totalServiceFeePayable)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = scheduledBegnningPrinciple;
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = totalAmountToPay + totalServiceFeePayable +
                                                                         ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                      managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;
                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);

                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                if (scheduleInput.Residual > 0)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                }
                                outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;

                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                          (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                          (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule
                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;

                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                               outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                               outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                               outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                               outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }
                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    PaymentDetailIndex = PaymentDetailIndex + 1;
                    inputGridRowIndex++;
                }
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        /// <summary>
        /// MaintenanceFeeAllocation() allocate the Maintenance fee amount after that reschedule all amount after addition of Maintenance Fee schedules.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="additionalPaymentlDate"></param>
        /// <param name="addtionalPaymentAmount"></param>
        /// <param name="additionalIndex"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="outputSchedule"></param>
        private static void MaintenanceFeeAllocation(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, DateTime additionalPaymentlDate, double addtionalPaymentAmount, int additionalIndex, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable, getScheduleOutput outputSchedule, double totalEarnedFeePerschedule)
        {
            #region
            int indexConut;
            int managementFeeTableIndex = 0;
            int maintenanceFeeTableIndex = 0;
            double managementFeePayable = 0;
            double maintenanceFeePayable = 0;
            int lastManagementFeeChargedIndex = -1;
            int lastMaintenanceFeeChargedIndex = -1;
            StringBuilder sbTracing = new StringBuilder();
            DateTime endDate = Convert.ToDateTime(Constants.DefaultDate);
            DateTime startDate = Convert.ToDateTime(Constants.DefaultDate);
            Boolean FirstOne = false;
            double intrestRate = 0;
            double interestCarryOver = 0;
            double serviceFeeInterestCarryover = 0;
            double interestAccrued = 0;
            double serviceFeeInterest = 0;
            double begnningPrincipal = 0;
            double begnningServiceFee = 0;
            int PaymentDetailIndex = 0;
            double periodicInterestRate = 0;
            double scheduledInterest = 0;
            double scheduledInterestCarryOver = 0;
            double paymentAmount = 0;
            int inputGridRow = 0;
            int inputIndex = 0;
            int inputGridRowIndex = 1;
            double dailyInterestRate = 0;
            double dailyInterestAmount = 0;
            int additionalGridRowIndex = 0;
            double totalAmountToPay = Round.RoundOffAmount(defaultTotalAmountToPay);
            double totalServiceFeePayable = Round.RoundOffAmount(defaultTotalServiceFeePayable);
            double totalResidualPrincipal = 0;
            DateTime prorateFirstScheduleDate = scheduleInput.InputRecords[1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[1].DateIn : scheduleInput.InputRecords[1].EffectiveDate;
            #endregion
            try
            {
                #region Count index where we can add the new schedule for additional payment.
                while (PaymentDetailIndex < outputGrid.Count &&
                      additionalPaymentlDate >= outputGrid[PaymentDetailIndex].PaymentDate)
                {
                    if ((PaymentDetailIndex == outputGrid.FindLastIndex(o => o.PaymentDate == additionalPaymentlDate)) && additionalPaymentlDate == outputGrid[PaymentDetailIndex].PaymentDate)
                    {
                        if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                        {
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() method. Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            additionalGridRowIndex++;
                        }
                        else
                        {

                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            inputGridRowIndex++;

                        }
                        PaymentDetailIndex++;
                        break;
                    }
                    if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        additionalGridRowIndex++;
                    }
                    else
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        inputGridRowIndex++;
                    }
                    PaymentDetailIndex++;
                }
                #endregion
                FirstOne = true;
                while (PaymentDetailIndex < outputGrid.Count)
                {
                    if (FirstOne)
                    {
                        #region When additional payment schedule created
                        FirstOne = false;
                        begnningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                        begnningServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                        intrestRate = Convert.ToDouble(string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? scheduleInput.InterestRate : (scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate == "0" ? 0 : Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate)));

                        #region Find Start date and End date
                        if (PaymentDetailIndex <= 0 && intrestRate > 0)
                        {
                            //Calculate Periodic Interest rate when when it comes before the first schedule date
                            startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = additionalPaymentlDate;
                        }
                        else
                        {
                            if (intrestRate > 0 && PaymentDetailIndex >= 0)
                            {
                                //Calculate Periodic Interest rate when when comes before the first schedule
                                startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                                //It determines the end date. Interest will be calculated till the end date for that period.
                                endDate = additionalPaymentlDate;
                            }
                            else
                            {
                                periodicInterestRate = 0;
                                endDate = additionalPaymentlDate;
                            }
                        }
                        #endregion

                        #region Add row for additional Payment
                        if (PaymentDetailIndex > 0)
                        {
                            #region Add Additional payment for maintenance fee only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = 0,
                                DailyInterestRate = 0,
                                DailyInterestAmount = 0,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = 0,
                                InterestCarryOver = 0,
                                InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = 0,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterest = Round.RoundOffAmount((Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue))),
                                ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue + outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue)),
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFee = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue)),
                                ManagementFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue),
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                InterestPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                ServiceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterestPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue),
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFeePastDue = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue)),
                                ManagementFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue),
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });

                            #endregion
                        }
                        else
                        {
                            #region Add Additional payment for maintenance fee only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0,
                                InterestCarryOver = 0,
                                InterestPayment = PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0,
                                PrincipalPayment = 0,
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = 0,
                                ServiceFeeInterest = PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0,
                                ServiceFeeTotal = PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0,
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFee = PaymentDetailIndex == 0 ? (addtionalPaymentAmount + scheduleInput.EarnedMaintenanceFee) : 0,
                                ManagementFee = PaymentDetailIndex == 0 ? scheduleInput.EarnedManagementFee : 0,
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee),
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee),
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = 0,
                                InterestPastDue = PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0,
                                ServiceFeePastDue = 0,
                                ServiceFeeInterestPastDue = PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0,
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFeePastDue = PaymentDetailIndex == 0 ? (addtionalPaymentAmount + scheduleInput.EarnedMaintenanceFee) : 0,
                                ManagementFeePastDue = PaymentDetailIndex == 0 ? scheduleInput.EarnedManagementFee : 0,
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee),
                                LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });
                            outputGrid[PaymentDetailIndex + 1].OriginationFee = 0;
                            outputGrid[PaymentDetailIndex + 1].SameDayFee = 0;
                            outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].serviceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].InterestCarryOver = 0;
                            #endregion
                        }
                        #endregion

                        PaymentDetailIndex = PaymentDetailIndex + 1;
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = Round.RoundOffAmount(begnningPrincipal);
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(begnningServiceFee);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                        intrestRate = Convert.ToDouble(string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? scheduleInput.InterestRate : (scheduleInput.InputRecords[inputIndex].InterestRate == "0" ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate)));
                        #region Calculate Priodic Intrest Rate for Next schedule

                        if (PaymentDetailIndex >= 0)
                        {
                            for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                            {
                                if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                                {
                                    //Find start date
                                    startDate = outputGrid[startindex].PaymentDate;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                                    break;
                                }
                                if (startindex == 0)
                                {
                                    //Find start date
                                    startDate = scheduleInput.InputRecords[0].DateIn;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                                    break;
                                }
                            }
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        // Calculate management amd maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) : 0;
                        serviceFeeInterestCarryover = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) : 0;
                        #region Calculate Principal payment amount

                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].InterestCarryOver);
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                            if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].DateIn;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = 0;
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                        }
                        #endregion

                        #region Calculate Service fee payment amount
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(scheduledInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                            }
                            else
                            {
                                if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                                {
                                    //Find start date
                                    startDate = outputGrid[startindex].PaymentDate;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].AccruedServiceFeeInterestCarryOver);
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                        }
                                    }
                                    break;
                                }
                                if (startindex == 0)
                                {
                                    //Find start date
                                    startDate = scheduleInput.InputRecords[0].DateIn;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    //scheduledInterestCarryOver = 0;
                                    scheduledInterestCarryOver = outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver;
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount((serviceFeePastdue - totalServiceFeePayable));
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        #endregion

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region Calulate interestCarryOver and InterestPayment amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                            }
                            else if ((interestAccrued + interestCarryOver) > totalAmountToPay)
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver) - totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestPayment = totalAmountToPay;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                            }
                            #endregion

                            #region Calulate serviceFeeInterestCarryOver and ServiceFeeInterest amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) > totalServiceFeePayable)
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover) - totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = totalServiceFeePayable;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                            outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                      (interestAccrued + interestCarryOver) : totalAmountToPay) +
                                                                      ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                      (serviceFeeInterest + serviceFeeInterestCarryover) : totalServiceFeePayable) +
                                                                       ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                         ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                         managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;

                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }

                            outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexConut = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexConut >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= scheduleInput.EnforcedPrincipal ? scheduleInput.EnforcedPrincipal : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }

                                    outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].PrincipalPayment) : totalAmountToPay) +
                                                                                ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].ServiceFee) : totalServiceFeePayable) +
                                                                                 ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + maintenanceFeePayable + totalEarnedFeePerschedule;
                                    outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    }
                                    outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;
                                }
                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                          (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                          (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule
                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;

                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion

                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                              outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                              outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                              outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                              outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }

                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion

                        #endregion
                    }
                    else
                    {
                        #region After additional payment Adjust schedule
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                        intrestRate = Convert.ToDouble(string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? scheduleInput.InterestRate : (scheduleInput.InputRecords[inputIndex].InterestRate == "0" ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate)));
                        double scheduledBegnningPrinciple = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) : 0;

                        #region Calculate Priodic Intrest Rate for Next schedule

                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                      PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        //This variable calls a function which calculate the service fee interest rate for that period.
                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver);
                        serviceFeeInterestCarryover = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver);


                        //Calculate management and maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }

                            #endregion
                        }

                        outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                        outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region calculate Principal Amount and Interest Accrued and interestCarryOver amount
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = totalResidualPrincipal;
                            if ((interestAccrued + interestCarryOver) >= totalAmountToPay)
                            {
                                interestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver)) - Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount(interestCarryOver);
                                interestAccrued = Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                            }
                            else
                            {
                                if ((interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                            }
                            #endregion

                            #region calculate serviceFee Amount and ServiceFeeInterest and serviceFeeInterestCarryover amount
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + serviceFeeInterestCarryover + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                                serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));

                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable)
                            {
                                serviceFeeInterestCarryover = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover)) - Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount(serviceFeeInterestCarryover);
                                serviceFeeInterest = Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                            }
                            else
                            {
                                if ((serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].BeginningServiceFee) > totalServiceFeePayable)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = scheduledBegnningPrinciple;

                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);

                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = totalAmountToPay + totalServiceFeePayable +
                                                                         ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                      managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;
                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexConut = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexConut >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                if (scheduleInput.Residual > 0)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                }
                                outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;

                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                          (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                          (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule

                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                               outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                               outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                               outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                               outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }
                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    PaymentDetailIndex = PaymentDetailIndex + 1;
                    inputGridRowIndex++;
                }
                #region Extended schedule if amount are remains past due
                if ((additionalPaymentlDate >= (scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].DateIn : scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate)) && (additionalPaymentlDate >= outputGrid[outputGrid.Count - 1].PaymentDate) && (outputGrid[outputGrid.Count - 1].InterestCarryOver > 0 || outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver > 0
                    || outputGrid[outputGrid.Count - 1].PrincipalPastDue > 0 || outputGrid[outputGrid.Count - 1].InterestPastDue > 0 || outputGrid[outputGrid.Count - 1].ServiceFeePastDue > 0
                    || outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue > 0 || outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue > 0 || outputGrid[outputGrid.Count - 1].ManagementFeePastDue > 0
                    || outputGrid[outputGrid.Count - 1].OriginationFeePastDue > 0 || outputGrid[outputGrid.Count - 1].SameDayFeePastDue > 0 || outputGrid[outputGrid.Count - 1].NSFFeePastDue > 0 || outputGrid[outputGrid.Count - 1].LateFeePastDue > 0))
                {
                    begnningPrincipal = Round.RoundOffAmount((outputGrid[outputGrid.Count - 1].BeginningPrincipal - outputGrid[outputGrid.Count - 1].PrincipalPaid));
                    begnningServiceFee = Round.RoundOffAmount((outputGrid[outputGrid.Count - 1].BeginningServiceFee - outputGrid[outputGrid.Count - 1].ServiceFeePaid));

                    #region Add Additional payment for Maintenance Fee 
                    outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                    {
                        PaymentDate = additionalPaymentlDate,
                        BeginningPrincipal = begnningPrincipal,
                        BeginningServiceFee = begnningServiceFee,
                        PeriodicInterestRate = 0,
                        DailyInterestRate = 0,
                        DailyInterestAmount = 0,
                        PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                        Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                        DueDate = additionalPaymentlDate,
                        InterestAccrued = 0,
                        InterestCarryOver = 0,
                        InterestPayment = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestPastDue),
                        PrincipalPayment = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].PrincipalPastDue),
                        PaymentDue = 0,
                        TotalPayment = 0,
                        AccruedServiceFeeInterest = 0,
                        AccruedServiceFeeInterestCarryOver = 0,
                        ServiceFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ServiceFeePastDue),
                        ServiceFeeInterest = Round.RoundOffAmount((Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue))),
                        OriginationFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].OriginationFeePastDue),
                        MaintenanceFee = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue)),
                        ManagementFee = Round.RoundOffAmount(Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ManagementFeePastDue)),
                        SameDayFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].SameDayFeePastDue),
                        NSFFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].NSFFeePastDue),
                        LateFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].LateFeePastDue),
                        //Paid amount columns
                        PrincipalPaid = 0,
                        InterestPaid = 0,
                        ServiceFeePaid = 0,
                        ServiceFeeInterestPaid = 0,
                        OriginationFeePaid = 0,
                        MaintenanceFeePaid = 0,
                        ManagementFeePaid = 0,
                        SameDayFeePaid = 0,
                        NSFFeePaid = 0,
                        LateFeePaid = 0,
                        TotalPaid = 0,
                        //Cumulative Amount paid column
                        CumulativeInterest = 0,
                        CumulativePrincipal = 0,
                        CumulativePayment = 0,
                        CumulativeServiceFee = 0,
                        CumulativeServiceFeeInterest = 0,
                        CumulativeServiceFeeTotal = 0,
                        CumulativeOriginationFee = 0,
                        CumulativeMaintenanceFee = 0,
                        CumulativeManagementFee = 0,
                        CumulativeSameDayFee = 0,
                        CumulativeNSFFee = 0,
                        CumulativeLateFee = 0,
                        CumulativeTotalFees = 0,

                        //Cumulative past due amount columns
                        CumulativePrincipalPastDue = 0,
                        CumulativeInterestPastDue = 0,
                        CumulativeServiceFeePastDue = 0,
                        CumulativeServiceFeeInterestPastDue = 0,
                        CumulativeOriginationFeePastDue = 0,
                        CumulativeMaintenanceFeePastDue = 0,
                        CumulativeManagementFeePastDue = 0,
                        CumulativeSameDayFeePastDue = 0,
                        CumulativeNSFFeePastDue = 0,
                        CumulativeLateFeePastDue = 0,
                        CumulativeTotalPastDue = 0,
                        BucketStatus = ""
                    });
                    outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex].ServiceFee));
                    //Past due amount columns
                    outputGrid[PaymentDetailIndex].PrincipalPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                    outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                    outputGrid[PaymentDetailIndex].ServiceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                    outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                    outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue));
                    outputGrid[PaymentDetailIndex].ManagementFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                    outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                    outputGrid[PaymentDetailIndex].NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                    outputGrid[PaymentDetailIndex].LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                    outputGrid[PaymentDetailIndex].TotalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPastDue + outputGrid[PaymentDetailIndex].InterestPastDue + outputGrid[PaymentDetailIndex].ServiceFeePastDue
                                                                 + outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue + outputGrid[PaymentDetailIndex].MaintenanceFeePastDue + outputGrid[PaymentDetailIndex].ManagementFeePastDue
                                                                 + outputGrid[PaymentDetailIndex].SameDayFeePastDue + outputGrid[PaymentDetailIndex].NSFFeePastDue + outputGrid[PaymentDetailIndex].LateFeePastDue));
                    #endregion
                }
                #endregion
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        /// <summary>
        /// ManagementFeeAllocation() allocate the ManagementFee fee amount after that reschedule all amount after addition of Management Fee schedules.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="additionalPaymentlDate"></param>
        /// <param name="addtionalPaymentAmount"></param>
        /// <param name="additionalIndex"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="outputSchedule"></param>
        private static void ManagementFeeAllocation(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, DateTime additionalPaymentlDate, double addtionalPaymentAmount, int additionalIndex, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable, getScheduleOutput outputSchedule, double totalEarnedFeePerschedule)
        {
            #region
            int indexCount;
            int managementFeeTableIndex = 0;
            int maintenanceFeeTableIndex = 0;
            double managementFeePayable = 0;
            double maintenanceFeePayable = 0;
            int lastManagementFeeChargedIndex = -1;
            int lastMaintenanceFeeChargedIndex = -1;
            StringBuilder sbTracing = new StringBuilder();
            DateTime endDate = Convert.ToDateTime(Constants.DefaultDate);
            DateTime startDate = Convert.ToDateTime(Constants.DefaultDate);
            Boolean FirstOne = false;
            double intrestRate = 0;
            double interestCarryOver = 0;
            double serviceFeeInterestCarryover = 0;
            double interestAccrued = 0;
            double serviceFeeInterest = 0;
            double begnningPrincipal = 0;
            double begnningServiceFee = 0;
            int PaymentDetailIndex = 0;
            double periodicInterestRate = 0;
            double scheduledInterest = 0;
            double scheduledInterestCarryOver = 0;
            double paymentAmount = 0;
            int inputGridRow = 0;
            int inputIndex = 0;
            int inputGridRowIndex = 1;
            double dailyInterestRate = 0;
            double dailyInterestAmount = 0;
            int additionalGridRowIndex = 0;
            double totalAmountToPay = Round.RoundOffAmount(defaultTotalAmountToPay);
            double totalServiceFeePayable = Round.RoundOffAmount(defaultTotalServiceFeePayable);
            double totalResidualPrincipal = 0;
            DateTime prorateFirstScheduleDate = scheduleInput.InputRecords[1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[1].DateIn : scheduleInput.InputRecords[1].EffectiveDate;
            #endregion
            try
            {
                #region Count index where we can add the new schedule for additional payment.
                while (PaymentDetailIndex < outputGrid.Count &&
                      additionalPaymentlDate >= outputGrid[PaymentDetailIndex].PaymentDate)
                {
                    if ((PaymentDetailIndex == outputGrid.FindLastIndex(o => o.PaymentDate == additionalPaymentlDate)) && additionalPaymentlDate == outputGrid[PaymentDetailIndex].PaymentDate)
                    {
                        if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                        {
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() method. Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            additionalGridRowIndex++;
                        }
                        else
                        {

                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            inputGridRowIndex++;

                        }
                        PaymentDetailIndex++;
                        break;
                    }
                    if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and ManagementFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and ManagementFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        additionalGridRowIndex++;
                    }
                    else
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and ManagementFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and ManagementFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        inputGridRowIndex++;
                    }
                    PaymentDetailIndex++;
                }
                #endregion
                FirstOne = true;
                while (PaymentDetailIndex < outputGrid.Count)
                {
                    if (FirstOne)
                    {
                        #region When additional payment schedule created
                        FirstOne = false;
                        begnningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                        begnningServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                        intrestRate = Convert.ToDouble(string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? scheduleInput.InterestRate : (scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate == "0" ? 0 : Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate)));

                        #region Find Start date and End date
                        if (PaymentDetailIndex <= 0 && intrestRate > 0)
                        {
                            //Calculate Periodic Interest rate when when it comes before the first schedule date
                            startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = additionalPaymentlDate;
                        }
                        else
                        {
                            if (intrestRate > 0 && PaymentDetailIndex >= 0)
                            {
                                //Calculate Periodic Interest rate when when comes before the first schedule
                                startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                                //It determines the end date. Interest will be calculated till the end date for that period.
                                endDate = additionalPaymentlDate;
                            }
                            else
                            {
                                periodicInterestRate = 0;
                                endDate = additionalPaymentlDate;
                            }
                        }
                        #endregion

                        #region Add row for additional Payment
                        if (PaymentDetailIndex > 0)
                        {
                            #region Add Additional payment for maintenance fee only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = 0,
                                DailyInterestRate = 0,
                                DailyInterestAmount = 0,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = 0,
                                InterestCarryOver = 0,
                                InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = 0,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterest = Round.RoundOffAmount((Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue))),
                                ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue + outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue)),
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue),
                                ManagementFee = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue)),
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                InterestPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue),
                                ServiceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterestPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue),
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue),
                                ManagementFeePastDue = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue)),
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });

                            #endregion
                        }
                        else
                        {
                            #region Add Additional payment for maintenance fee only
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0,
                                InterestCarryOver = 0,
                                InterestPayment = PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0,
                                PrincipalPayment = 0,
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = 0,
                                ServiceFeeInterest = PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0,
                                ServiceFeeTotal = PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0,
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFee = PaymentDetailIndex == 0 ? scheduleInput.EarnedMaintenanceFee : 0,
                                ManagementFee = PaymentDetailIndex == 0 ? (addtionalPaymentAmount + scheduleInput.EarnedManagementFee) : 0,
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee),
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee),
                                //Paid amount columns
                                PrincipalPaid = 0,
                                InterestPaid = 0,
                                ServiceFeePaid = 0,
                                ServiceFeeInterestPaid = 0,
                                OriginationFeePaid = 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = 0,
                                InterestPastDue = PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0,
                                ServiceFeePastDue = 0,
                                ServiceFeeInterestPastDue = PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0,
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFeePastDue = PaymentDetailIndex == 0 ? scheduleInput.EarnedMaintenanceFee : 0,
                                ManagementFeePastDue = PaymentDetailIndex == 0 ? (addtionalPaymentAmount + scheduleInput.EarnedManagementFee) : 0,
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee),
                                LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });
                            outputGrid[PaymentDetailIndex + 1].OriginationFee = 0;
                            outputGrid[PaymentDetailIndex + 1].SameDayFee = 0;
                            outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].serviceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].InterestCarryOver = 0;
                            #endregion
                        }
                        #endregion

                        PaymentDetailIndex = PaymentDetailIndex + 1;
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = Round.RoundOffAmount(begnningPrincipal);
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(begnningServiceFee);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                        intrestRate = Convert.ToDouble(string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? scheduleInput.InterestRate : (scheduleInput.InputRecords[inputIndex].InterestRate == "0" ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate)));
                        #region Calculate Priodic Intrest Rate for Next schedule

                        if (PaymentDetailIndex >= 0)
                        {
                            for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                            {
                                if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                                {
                                    //Find start date
                                    startDate = outputGrid[startindex].PaymentDate;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                                    break;
                                }
                                if (startindex == 0)
                                {
                                    //Find start date
                                    startDate = scheduleInput.InputRecords[0].DateIn;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                                    break;
                                }
                            }
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion
                        // Calculate management amd maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);

                        interestCarryOver = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) : 0;
                        serviceFeeInterestCarryover = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) : 0;
                        #region Calculate Principal payment amount
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].InterestCarryOver);
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                            if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].DateIn;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = 0;
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                        }
                        #endregion

                        #region Calculate Service fee payment amount
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(scheduledInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                            }
                            else
                            {
                                if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                                {
                                    //Find start date
                                    startDate = outputGrid[startindex].PaymentDate;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                                        PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].AccruedServiceFeeInterestCarryOver);
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                                if (startindex == 0)
                                {
                                    //Find start date
                                    startDate = scheduleInput.InputRecords[0].DateIn;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                                                   PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver;
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        #endregion

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region Calulate interestCarryOver and InterestPayment amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                            }
                            else if ((interestAccrued + interestCarryOver) > totalAmountToPay)
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver) - totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestPayment = totalAmountToPay;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                            }
                            #endregion

                            #region Calulate serviceFeeInterestCarryOver and ServiceFeeInterest amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) > totalServiceFeePayable)
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover) - totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = totalServiceFeePayable;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                            outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;

                            outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                     (interestAccrued + interestCarryOver) : totalAmountToPay) +
                                                                     ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                     (serviceFeeInterest + serviceFeeInterestCarryover) : totalServiceFeePayable) +
                                                                     ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;
                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= scheduleInput.EnforcedPrincipal ? scheduleInput.EnforcedPrincipal : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }

                                    outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].PrincipalPayment) : totalAmountToPay) +
                                                                                ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].ServiceFee) : totalServiceFeePayable) +
                                                                                 ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + maintenanceFeePayable + totalEarnedFeePerschedule;
                                    outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    }
                                    outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;
                                }
                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                          (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) : (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule
                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;

                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                              outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                              outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                              outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                              outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }

                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    else
                    {
                        #region After additional payment Adjust schedule
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                        intrestRate = Convert.ToDouble(string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? scheduleInput.InterestRate : (scheduleInput.InputRecords[inputIndex].InterestRate == "0" ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate)));
                        double scheduledBegnningPrinciple = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) : 0;

                        #region Calculate Priodic Intrest Rate for Next schedule
                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver);
                        serviceFeeInterestCarryover = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver);

                        //Calculate management and maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and MaintenanceFeeAllocation() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }

                            #endregion
                        }

                        outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                        outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region calculate Principal Amount and Interest Accrued and interestCarryOver amount
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = totalResidualPrincipal;
                            if ((interestAccrued + interestCarryOver) >= totalAmountToPay)
                            {
                                interestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver)) - Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount(interestCarryOver);
                                interestAccrued = Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                            }
                            else
                            {
                                if ((interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                            }
                            #endregion

                            #region calculate serviceFee Amount and ServiceFeeInterest and serviceFeeInterestCarryover amount
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + serviceFeeInterestCarryover + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                                serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));

                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable)
                            {
                                serviceFeeInterestCarryover = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover)) - Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount(serviceFeeInterestCarryover);
                                serviceFeeInterest = Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                            }
                            else
                            {
                                if ((serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].BeginningServiceFee) > totalServiceFeePayable)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = scheduledBegnningPrinciple;

                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = totalAmountToPay + totalServiceFeePayable +
                                                                         ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                      managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;
                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);
                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                if (scheduleInput.Residual > 0)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                }
                                outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;

                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                          (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                          (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule
                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                               outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                               outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                               outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                               outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }
                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 &&
                            outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 &&
                            outputGrid[PaymentDetailIndex].LateFee <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    PaymentDetailIndex = PaymentDetailIndex + 1;
                    inputGridRowIndex++;
                }
                #region Extended schedule if amount are remains past due
                if ((additionalPaymentlDate >= (scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].DateIn : scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate)) && (additionalPaymentlDate >= outputGrid[outputGrid.Count - 1].PaymentDate) && (outputGrid[outputGrid.Count - 1].InterestCarryOver > 0 || outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver > 0
                    || outputGrid[outputGrid.Count - 1].PrincipalPastDue > 0 || outputGrid[outputGrid.Count - 1].InterestPastDue > 0 || outputGrid[outputGrid.Count - 1].ServiceFeePastDue > 0
                    || outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue > 0 || outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue > 0 || outputGrid[outputGrid.Count - 1].ManagementFeePastDue > 0
                    || outputGrid[outputGrid.Count - 1].OriginationFeePastDue > 0 || outputGrid[outputGrid.Count - 1].SameDayFeePastDue > 0 || outputGrid[outputGrid.Count - 1].NSFFeePastDue > 0 || outputGrid[outputGrid.Count - 1].LateFeePastDue > 0))
                {
                    begnningPrincipal = Round.RoundOffAmount((outputGrid[outputGrid.Count - 1].BeginningPrincipal - outputGrid[outputGrid.Count - 1].PrincipalPaid));
                    begnningServiceFee = Round.RoundOffAmount((outputGrid[outputGrid.Count - 1].BeginningServiceFee - outputGrid[outputGrid.Count - 1].ServiceFeePaid));
                    #region Add Additional payment for Maintenance Fee 
                    outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                    {
                        PaymentDate = additionalPaymentlDate,
                        BeginningPrincipal = begnningPrincipal,
                        BeginningServiceFee = begnningServiceFee,
                        PeriodicInterestRate = 0,
                        DailyInterestRate = 0,
                        DailyInterestAmount = 0,
                        PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                        Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                        DueDate = additionalPaymentlDate,
                        InterestAccrued = 0,
                        InterestCarryOver = 0,
                        InterestPayment = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].InterestPastDue),
                        PrincipalPayment = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].PrincipalPastDue),
                        PaymentDue = 0,
                        TotalPayment = 0,
                        AccruedServiceFeeInterest = 0,
                        AccruedServiceFeeInterestCarryOver = 0,
                        ServiceFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ServiceFeePastDue),
                        ServiceFeeInterest = Round.RoundOffAmount((Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue))),
                        OriginationFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].OriginationFeePastDue),
                        MaintenanceFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue),
                        ManagementFee = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[outputGrid.Count - 1].ManagementFeePastDue)),
                        SameDayFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].SameDayFeePastDue),
                        NSFFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].NSFFeePastDue),
                        LateFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].LateFeePastDue),
                        //Paid amount columns
                        PrincipalPaid = 0,
                        InterestPaid = 0,
                        ServiceFeePaid = 0,
                        ServiceFeeInterestPaid = 0,
                        OriginationFeePaid = 0,
                        MaintenanceFeePaid = 0,
                        ManagementFeePaid = 0,
                        SameDayFeePaid = 0,
                        NSFFeePaid = 0,
                        LateFeePaid = 0,
                        TotalPaid = 0,
                        //Cumulative Amount paid column
                        CumulativeInterest = 0,
                        CumulativePrincipal = 0,
                        CumulativePayment = 0,
                        CumulativeServiceFee = 0,
                        CumulativeServiceFeeInterest = 0,
                        CumulativeServiceFeeTotal = 0,
                        CumulativeOriginationFee = 0,
                        CumulativeMaintenanceFee = 0,
                        CumulativeManagementFee = 0,
                        CumulativeSameDayFee = 0,
                        CumulativeNSFFee = 0,
                        CumulativeLateFee = 0,
                        CumulativeTotalFees = 0,

                        //Cumulative past due amount columns
                        CumulativePrincipalPastDue = 0,
                        CumulativeInterestPastDue = 0,
                        CumulativeServiceFeePastDue = 0,
                        CumulativeServiceFeeInterestPastDue = 0,
                        CumulativeOriginationFeePastDue = 0,
                        CumulativeMaintenanceFeePastDue = 0,
                        CumulativeManagementFeePastDue = 0,
                        CumulativeSameDayFeePastDue = 0,
                        CumulativeNSFFeePastDue = 0,
                        CumulativeLateFeePastDue = 0,
                        CumulativeTotalPastDue = 0,
                        BucketStatus = ""
                    });
                    outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex].ServiceFee));
                    //Past due amount columns
                    outputGrid[PaymentDetailIndex].PrincipalPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                    outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                    outputGrid[PaymentDetailIndex].ServiceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                    outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                    outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                    outputGrid[PaymentDetailIndex].ManagementFeePastDue = Round.RoundOffAmount((addtionalPaymentAmount + outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue));
                    outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                    outputGrid[PaymentDetailIndex].NSFFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                    outputGrid[PaymentDetailIndex].LateFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                    outputGrid[PaymentDetailIndex].TotalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPastDue + outputGrid[PaymentDetailIndex].InterestPastDue + outputGrid[PaymentDetailIndex].ServiceFeePastDue
                                                                 + outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue + outputGrid[PaymentDetailIndex].MaintenanceFeePastDue + outputGrid[PaymentDetailIndex].ManagementFeePastDue
                                                                 + outputGrid[PaymentDetailIndex].SameDayFeePastDue + outputGrid[PaymentDetailIndex].NSFFeePastDue + outputGrid[PaymentDetailIndex].LateFeePastDue));
                    #endregion
                }
                #endregion
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        /// <summary>
        /// Discount() method calculates discount on the fee.
        /// </summary>
        /// <param name="outputGrid"></param>
        /// <param name="scheduleInput"></param>
        /// <param name="additionalPaymentlDate"></param>
        /// <param name="addtionalPaymentAmount"></param>
        /// <param name="additionalIndex"></param>
        /// <param name="defaultTotalAmountToPay"></param>
        /// <param name="defaultTotalServiceFeePayable"></param>
        /// <param name="outputSchedule"></param>
        private static void Discount(List<PaymentDetail> outputGrid, getScheduleInput scheduleInput, DateTime additionalPaymentlDate, int additionalIndex, double defaultTotalAmountToPay, double defaultTotalServiceFeePayable, getScheduleOutput outputSchedule, double totalEarnedFeePerschedule)
        {
            #region
            int indexCount;
            int managementFeeTableIndex = 0;
            int maintenanceFeeTableIndex = 0;
            double managementFeePayable = 0;
            double maintenanceFeePayable = 0;
            int lastManagementFeeChargedIndex = -1;
            int lastMaintenanceFeeChargedIndex = -1;
            StringBuilder sbTracing = new StringBuilder();
            DateTime endDate = Convert.ToDateTime(Constants.DefaultDate);
            DateTime startDate = Convert.ToDateTime(Constants.DefaultDate);
            Boolean FirstOne = false;
            double interestCarryOver = 0;
            double serviceFeeInterestCarryover = 0;
            double interestAccrued = 0;
            double serviceFeeInterest = 0;
            double begnningPrincipal = 0;
            double begnningServiceFee = 0;
            int PaymentDetailIndex = 0;
            double periodicInterestRate = 0;
            double scheduledInterest = 0;
            double scheduledInterestCarryOver = 0;
            double totalInterestPayment = 0;
            double totalServiceFeeInterestPayment = 0;
            int inputIndex = 0;
            int inputGridRowIndex = 1;
            double paymentAmount = 0;
            int inputGridRow = 0;
            double dailyInterestRate = 0;
            double dailyInterestAmount = 0;
            int additionalGridRowIndex = 0;
            double totalAmountToPay = Round.RoundOffAmount(defaultTotalAmountToPay);
            double totalServiceFeePayable = Round.RoundOffAmount(defaultTotalServiceFeePayable);
            double totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
            DateTime prorateFirstScheduleDate = scheduleInput.InputRecords[1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[1].DateIn : scheduleInput.InputRecords[1].EffectiveDate;
            #endregion
            try
            {
                #region Count index where we can add the new schedule for additional payment.
                while (PaymentDetailIndex < outputGrid.Count &&
                      additionalPaymentlDate >= outputGrid[PaymentDetailIndex].PaymentDate)
                {

                    if ((PaymentDetailIndex == outputGrid.FindLastIndex(o => o.PaymentDate == additionalPaymentlDate)) && additionalPaymentlDate == outputGrid[PaymentDetailIndex].PaymentDate)
                    {
                        if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                        {
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() method. Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            additionalGridRowIndex++;
                        }
                        else
                        {

                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                            managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                            sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and PrincipalOnlyPayment() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                            maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                            inputGridRowIndex++;

                        }
                        PaymentDetailIndex++;
                        break;
                    }
                    if ((outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.Payment && outputGrid[PaymentDetailIndex].Flags != (int)Constants.FlagValues.SkipPayment))
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, additionalGridRowIndex, true, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        additionalGridRowIndex++;
                    }
                    else
                    {
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        inputGridRowIndex++;
                    }
                    PaymentDetailIndex++;
                }
                #endregion
                FirstOne = true;
                while (PaymentDetailIndex < outputGrid.Count)
                {
                    if (FirstOne)
                    {
                        #region When additional payment schedule created
                        FirstOne = false;
                        begnningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                        begnningServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;

                        #region Calculate Priodic Intrest Rate
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }
                            else if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                                //Find end date
                                endDate = additionalPaymentlDate;
                                periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                                break;
                            }

                        }
                        if (PaymentDetailIndex == 0)
                        {
                            //Find start date
                            startDate = scheduleInput.InputRecords[0].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[0].DateIn : scheduleInput.InputRecords[0].EffectiveDate;
                            //Find end date
                            endDate = additionalPaymentlDate;
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, false, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, false, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, false);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        interestAccrued = Round.RoundOffAmount(interestAccrued);
                        interestAccrued += PaymentDetailIndex == 0 ? scheduleInput.EarnedInterest : 0;
                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, false, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        serviceFeeInterest += PaymentDetailIndex == 0 ? scheduleInput.EarnedServiceFeeInterest : 0;
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }

                        #region Add additional Payment row for Discount
                        if (PaymentDetailIndex > 0)
                        {
                            #region Add Additional payment for Discount
                            totalInterestPayment = Round.RoundOffAmount((interestAccrued + outputGrid[PaymentDetailIndex - 1].InterestCarryOver + outputGrid[PaymentDetailIndex - 1].InterestPastDue));
                            totalServiceFeeInterestPayment = Round.RoundOffAmount((serviceFeeInterest + outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue));
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = totalInterestPayment,
                                PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue),
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue),
                                ServiceFeeInterest = totalServiceFeeInterestPayment,
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue),
                                MaintenanceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue),
                                ManagementFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue),
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue),
                                NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue),
                                LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue),
                                //Paid amount columns
                                PrincipalPaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount <= Round.RoundOffAmount(begnningPrincipal) ?
                                               scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount : Round.RoundOffAmount(begnningPrincipal)) : 0,

                                InterestPaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestDiscount < totalInterestPayment ?
                                                scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestDiscount : totalInterestPayment) : 0,

                                ServiceFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeDiscount <= Round.RoundOffAmount(begnningServiceFee) ?
                                                scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeDiscount : Round.RoundOffAmount(begnningServiceFee)) : 0,
                                ServiceFeeInterestPaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeInterestDiscount >= 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeInterestDiscount < totalServiceFeeInterestPayment ?
                                               scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeInterestDiscount : totalServiceFeeInterestPayment) : 0,

                                OriginationFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].OriginationFeeDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].OriginationFeeDiscount <= outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue ?
                                               scheduleInput.AdditionalPaymentRecords[additionalIndex].OriginationFeeDiscount : outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue) : 0,

                                MaintenanceFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].MaintenanceFeeDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].MaintenanceFeeDiscount <= outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue ?
                                               scheduleInput.AdditionalPaymentRecords[additionalIndex].MaintenanceFeeDiscount : outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue) : 0,

                                ManagementFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].ManagementFeeDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].ManagementFeeDiscount <= outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue ?
                                              scheduleInput.AdditionalPaymentRecords[additionalIndex].ManagementFeeDiscount : outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue) : 0,

                                SameDayFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].SameDayFeeDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].SameDayFeeDiscount <= outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue ?
                                                scheduleInput.AdditionalPaymentRecords[additionalIndex].SameDayFeeDiscount : outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue) : 0,

                                NSFFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].NSFFeeDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].NSFFeeDiscount <= outputGrid[PaymentDetailIndex - 1].NSFFeePastDue ?
                                               scheduleInput.AdditionalPaymentRecords[additionalIndex].NSFFeeDiscount : outputGrid[PaymentDetailIndex - 1].NSFFeePastDue) : 0,

                                LateFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].LateFeeDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].LateFeeDiscount <= outputGrid[PaymentDetailIndex - 1].LateFeePastDue ?
                                                scheduleInput.AdditionalPaymentRecords[additionalIndex].LateFeeDiscount : outputGrid[PaymentDetailIndex - 1].LateFeePastDue) : 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,

                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });
                            if (scheduleInput.Residual > 0)//Calculate principal for Residual
                            {
                                #region  For the Residual principal amount
                                totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                                for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                                {
                                    totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                                }
                                totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                                if (totalResidualPrincipal > scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount)
                                {
                                    totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount);
                                }
                                else
                                {
                                    if (totalResidualPrincipal > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPaid = totalResidualPrincipal;
                                        totalResidualPrincipal = 0;
                                    }
                                    else
                                    {
                                        if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                        outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                        {
                                            totalResidualPrincipal = 0;
                                            outputGrid[PaymentDetailIndex].PrincipalPaid = 0;
                                        }
                                        else
                                        {
                                            totalResidualPrincipal = 0;
                                            outputGrid[PaymentDetailIndex].PrincipalPaid = 0;
                                            outputGrid[PaymentDetailIndex].InterestAccrued = 0;
                                            outputGrid[PaymentDetailIndex].DailyInterestAmount = 0;
                                        }
                                    }
                                }
                                #endregion
                            }

                            outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex].ServiceFee));
                            //Past due amount columns
                            outputGrid[PaymentDetailIndex].PrincipalPastDue = outputGrid[PaymentDetailIndex].PrincipalPayment - outputGrid[PaymentDetailIndex].PrincipalPaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPayment - outputGrid[PaymentDetailIndex].PrincipalPaid));

                            outputGrid[PaymentDetailIndex].InterestPastDue = outputGrid[PaymentDetailIndex].InterestPayment - outputGrid[PaymentDetailIndex].InterestPaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].InterestPayment - outputGrid[PaymentDetailIndex].InterestPaid));

                            outputGrid[PaymentDetailIndex].ServiceFeePastDue = outputGrid[PaymentDetailIndex].ServiceFee - outputGrid[PaymentDetailIndex].ServiceFeePaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee - outputGrid[PaymentDetailIndex].ServiceFeePaid));

                            outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = outputGrid[PaymentDetailIndex].ServiceFeeInterest - outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest - outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid));

                            outputGrid[PaymentDetailIndex].OriginationFeePastDue = outputGrid[PaymentDetailIndex].OriginationFee - outputGrid[PaymentDetailIndex].OriginationFeePaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee - outputGrid[PaymentDetailIndex].OriginationFeePaid));

                            outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = outputGrid[PaymentDetailIndex].MaintenanceFee - outputGrid[PaymentDetailIndex].MaintenanceFeePaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee - outputGrid[PaymentDetailIndex].MaintenanceFeePaid));

                            outputGrid[PaymentDetailIndex].ManagementFeePastDue = outputGrid[PaymentDetailIndex].ManagementFee - outputGrid[PaymentDetailIndex].ManagementFeePaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee - outputGrid[PaymentDetailIndex].ManagementFeePaid));

                            outputGrid[PaymentDetailIndex].SameDayFeePastDue = outputGrid[PaymentDetailIndex].SameDayFee - outputGrid[PaymentDetailIndex].SameDayFeePaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee - outputGrid[PaymentDetailIndex].SameDayFeePaid));

                            outputGrid[PaymentDetailIndex].NSFFeePastDue = outputGrid[PaymentDetailIndex].NSFFee - outputGrid[PaymentDetailIndex].NSFFeePaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].NSFFee - outputGrid[PaymentDetailIndex].NSFFeePaid));

                            outputGrid[PaymentDetailIndex].LateFeePastDue = outputGrid[PaymentDetailIndex].LateFee - outputGrid[PaymentDetailIndex].LateFeePaid < 0 ? 0 : Round.RoundOffAmount((outputGrid[PaymentDetailIndex].LateFee - outputGrid[PaymentDetailIndex].LateFeePaid));

                            outputGrid[PaymentDetailIndex].TotalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPastDue + outputGrid[PaymentDetailIndex].InterestPastDue
                                                                          + outputGrid[PaymentDetailIndex].ServiceFeePastDue + outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue
                                                                          + outputGrid[PaymentDetailIndex].OriginationFeePastDue + outputGrid[PaymentDetailIndex].MaintenanceFeePastDue
                                                                          + outputGrid[PaymentDetailIndex].ManagementFeePastDue + outputGrid[PaymentDetailIndex].SameDayFeePastDue
                                                                          + outputGrid[PaymentDetailIndex].NSFFeePastDue + outputGrid[PaymentDetailIndex].LateFeePastDue));
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid
                                                                       + outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid
                                                                       + outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid
                                                                       + outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid
                                                                       + outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid));
                            #endregion
                        }
                        else
                        {
                            #region Add Additional payment for Discount
                            outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                            {
                                PaymentDate = endDate,
                                BeginningPrincipal = begnningPrincipal,
                                BeginningServiceFee = begnningServiceFee,
                                PeriodicInterestRate = periodicInterestRate,
                                DailyInterestRate = dailyInterestRate,
                                DailyInterestAmount = dailyInterestAmount,
                                PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                                Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                                DueDate = endDate,
                                InterestAccrued = interestAccrued,
                                InterestCarryOver = 0,
                                InterestPayment = interestAccrued,
                                PrincipalPayment = 0,
                                PaymentDue = 0,
                                TotalPayment = 0,
                                AccruedServiceFeeInterest = serviceFeeInterest,
                                AccruedServiceFeeInterestCarryOver = 0,
                                ServiceFee = 0,
                                ServiceFeeInterest = serviceFeeInterest,
                                ServiceFeeTotal = serviceFeeInterest,
                                OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(maintenanceFeePayable) : 0) + scheduleInput.EarnedMaintenanceFee,
                                ManagementFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(managementFeePayable) : 0) + scheduleInput.EarnedManagementFee,
                                SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee) : 0),
                                LateFee = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee) : 0),
                                //Paid amount columns
                                PrincipalPaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount > 0 ?
                                                (scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount >= begnningPrincipal ? begnningPrincipal : scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount) : 0,
                                InterestPaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestDiscount < interestAccrued ?
                                               scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestDiscount : interestAccrued) : 0,
                                ServiceFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeDiscount > 0 ?
                                                (scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeDiscount >= begnningServiceFee ? begnningServiceFee : scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeDiscount) : 0,
                                ServiceFeeInterestPaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeInterestDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeInterestDiscount < serviceFeeInterest ?
                                               scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeInterestDiscount : serviceFeeInterest) : 0,
                                OriginationFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].OriginationFeeDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].OriginationFeeDiscount < outputGrid[PaymentDetailIndex].OriginationFee ?
                                               scheduleInput.AdditionalPaymentRecords[additionalIndex].OriginationFeeDiscount : outputGrid[PaymentDetailIndex].OriginationFee) : 0,
                                MaintenanceFeePaid = 0,
                                ManagementFeePaid = 0,
                                SameDayFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].SameDayFeeDiscount > 0 ?
                                               (scheduleInput.AdditionalPaymentRecords[additionalIndex].SameDayFeeDiscount < outputGrid[PaymentDetailIndex].SameDayFee ?
                                               scheduleInput.AdditionalPaymentRecords[additionalIndex].SameDayFeeDiscount : outputGrid[PaymentDetailIndex].SameDayFee) : 0,
                                NSFFeePaid = 0,
                                LateFeePaid = 0,
                                TotalPaid = 0,
                                //Cumulative Amount paid column
                                CumulativeInterest = 0,
                                CumulativePrincipal = 0,
                                CumulativePayment = 0,
                                CumulativeServiceFee = 0,
                                CumulativeServiceFeeInterest = 0,
                                CumulativeServiceFeeTotal = 0,
                                CumulativeOriginationFee = 0,
                                CumulativeMaintenanceFee = 0,
                                CumulativeManagementFee = 0,
                                CumulativeSameDayFee = 0,
                                CumulativeNSFFee = 0,
                                CumulativeLateFee = 0,
                                CumulativeTotalFees = 0,
                                //Past due amount columns
                                PrincipalPastDue = 0,
                                InterestPastDue = 0,
                                ServiceFeePastDue = 0,
                                ServiceFeeInterestPastDue = 0,
                                OriginationFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee),
                                MaintenanceFeePastDue = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(maintenanceFeePayable) : 0) + scheduleInput.EarnedMaintenanceFee,
                                ManagementFeePastDue = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(managementFeePayable) : 0) + scheduleInput.EarnedManagementFee,
                                SameDayFeePastDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee),
                                NSFFeePastDue = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFee) : 0),
                                LateFeePastDue = (PaymentDetailIndex == 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFee) : 0),
                                TotalPastDue = 0,
                                //Cumulative past due amount columns
                                CumulativePrincipalPastDue = 0,
                                CumulativeInterestPastDue = 0,
                                CumulativeServiceFeePastDue = 0,
                                CumulativeServiceFeeInterestPastDue = 0,
                                CumulativeOriginationFeePastDue = 0,
                                CumulativeMaintenanceFeePastDue = 0,
                                CumulativeManagementFeePastDue = 0,
                                CumulativeSameDayFeePastDue = 0,
                                CumulativeNSFFeePastDue = 0,
                                CumulativeLateFeePastDue = 0,
                                CumulativeTotalPastDue = 0,
                                BucketStatus = ""
                            });

                            if (scheduleInput.Residual > 0)//Calculate principal for Residual
                            {
                                #region  For the Residual principal amount
                                totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                                for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                                {
                                    totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                                }
                                totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                                if (totalResidualPrincipal > scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount)
                                {
                                    totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount);
                                }
                                else
                                {
                                    if (totalResidualPrincipal > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPaid = totalResidualPrincipal;
                                        totalResidualPrincipal = 0;
                                    }
                                    else
                                    {
                                        if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                        outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                        {
                                            totalResidualPrincipal = 0;
                                            outputGrid[PaymentDetailIndex].PrincipalPaid = 0;
                                        }
                                        else
                                        {
                                            totalResidualPrincipal = 0;
                                            outputGrid[PaymentDetailIndex].PrincipalPaid = 0;
                                            outputGrid[PaymentDetailIndex].InterestAccrued = 0;
                                            outputGrid[PaymentDetailIndex].DailyInterestAmount = 0;
                                        }
                                    }
                                }
                                #endregion
                            }
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid
                                                                       + outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid
                                                                       + outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid));
                            outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount(((outputGrid[PaymentDetailIndex].InterestPayment - outputGrid[PaymentDetailIndex].InterestPaid) >= 0 ? (outputGrid[PaymentDetailIndex].InterestPayment - outputGrid[PaymentDetailIndex].InterestPaid) : 0));
                            outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount(((outputGrid[PaymentDetailIndex].ServiceFeeInterest - outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid) >= 0 ? (outputGrid[PaymentDetailIndex].ServiceFeeInterest - outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid) : 0));
                            outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount(((outputGrid[PaymentDetailIndex].OriginationFee - outputGrid[PaymentDetailIndex].OriginationFeePaid) >= 0 ? (outputGrid[PaymentDetailIndex].OriginationFee - outputGrid[PaymentDetailIndex].OriginationFeePaid) : 0));
                            outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount(((outputGrid[PaymentDetailIndex].SameDayFee - outputGrid[PaymentDetailIndex].SameDayFeePaid) >= 0 ? (outputGrid[PaymentDetailIndex].SameDayFee - outputGrid[PaymentDetailIndex].SameDayFeePaid) : 0));

                            outputGrid[PaymentDetailIndex + 1].OriginationFee = 0;
                            outputGrid[PaymentDetailIndex + 1].SameDayFee = 0;
                            outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].serviceFeeInterestCarryOver = 0;
                            outputGrid[PaymentDetailIndex + 1].InterestCarryOver = 0;
                            #endregion
                        }
                        #endregion

                        outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                        outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));

                        PaymentDetailIndex = PaymentDetailIndex + 1;
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) : 0;
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);

                        #region Calculate Priodic Intrest Rate for Next schedule

                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);

                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion
                        //Calculate management amd maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside ActualPaymentAllocation LoanAmort_driver.RollingBusiness, class, and Discount() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver) : 0;
                        serviceFeeInterestCarryover = PaymentDetailIndex > 0 ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) : 0;
                        #region Calculate Principal payment amount
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                            {
                                //Find start date
                                startDate = outputGrid[startindex].PaymentDate;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].InterestCarryOver);
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                            if (startindex == 0)
                            {
                                //Find start date
                                startDate = scheduleInput.InputRecords[0].DateIn;
                                //Find end date
                                endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                //This variable calls a function which calculate the periodic interest rate for that period.
                                scheduledInterest = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                                scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                scheduledInterestCarryOver = 0;
                                if ((scheduledInterest + scheduledInterestCarryOver) >= totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    if ((scheduledInterest + scheduledInterestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    }
                                }
                                break;
                            }
                        }

                        #endregion

                        #region Calculate Service fee payment amount
                        for (int startindex = PaymentDetailIndex - 1; startindex >= 0; startindex--)
                        {
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(scheduledInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                            }
                            else
                            {
                                if (outputGrid[startindex].Flags == (int)Constants.FlagValues.Payment)
                                {
                                    //Find start date
                                    startDate = outputGrid[startindex].PaymentDate;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                                        PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = Round.RoundOffAmount(outputGrid[startindex].AccruedServiceFeeInterestCarryOver);
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                                if (startindex == 0)
                                {
                                    //Find start date
                                    startDate = scheduleInput.InputRecords[0].DateIn;
                                    //Find end date
                                    endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                                    //This variable calls a function which calculate the periodic interest rate for that period.
                                    scheduledInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                                                   PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);
                                    scheduledInterest = Round.RoundOffAmount(scheduledInterest);
                                    scheduledInterestCarryOver = outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver;
                                    double serviceFeePastdue = Round.RoundOffAmount((scheduledInterest + scheduledInterestCarryOver));
                                    if (serviceFeePastdue >= totalServiceFeePayable)
                                    {
                                        outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                    }
                                    else
                                    {
                                        if (serviceFeePastdue < totalServiceFeePayable && outputGrid[PaymentDetailIndex].BeginningServiceFee > 0)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeePastdue));
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                        }
                                        else
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        #endregion


                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                             outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }
                            #endregion
                        }
                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region Calulate interestCarryOver and InterestPayment amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(interestAccrued + interestCarryOver);
                            }
                            else if ((interestAccrued + interestCarryOver) > totalAmountToPay)
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver) - totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestPayment = totalAmountToPay;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                            }
                            #endregion

                            #region Calulate serviceFeeInterestCarryOver and ServiceFeeInterest amount
                            if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest + serviceFeeInterestCarryover);
                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) > totalServiceFeePayable)
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover) - totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = totalServiceFeePayable;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex].BeginningPrincipal;
                            outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                     (interestAccrued + interestCarryOver) : totalAmountToPay) +
                                                                     ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                     (serviceFeeInterest + serviceFeeInterestCarryover) : totalServiceFeePayable) +
                                                                     ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;

                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);

                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                if (scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate))//this condition is used for Prorate method
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= scheduleInput.EnforcedPrincipal ? scheduleInput.EnforcedPrincipal : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }

                                    outputGrid[PaymentDetailIndex].PaymentDue = ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (interestAccrued + interestCarryOver) >= totalAmountToPay && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].PrincipalPayment) : totalAmountToPay) +
                                                                                ((scheduleInput.MinDuration > Models.Constants.MinDurationValue && (serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable && (outputGrid[PaymentDetailIndex].PaymentDate <= prorateFirstScheduleDate)) ?
                                                                                (serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].ServiceFee) : totalServiceFeePayable) +
                                                                                 ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                       managementFeePayable + maintenanceFeePayable + totalEarnedFeePerschedule;
                                    outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                    if (scheduleInput.Residual > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                    }
                                    else
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                    }
                                    outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;
                                }
                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                                           (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ? scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) : (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule
                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                               outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                               outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                               outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                               outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }
                        #endregion
                    }
                    else
                    {
                        #region After additional payment Adjust schedule
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        inputIndex = scheduleInput.InputRecords.FindIndex(s => s.DateIn == outputGrid[PaymentDetailIndex].DueDate);
                        double scheduledBegnningPrinciple = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                        outputGrid[PaymentDetailIndex].BeginningServiceFee = outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) : 0;

                        #region Calculate Priodic Intrest Rate for Next schedule

                        if (PaymentDetailIndex >= 0)
                        {
                            //Calculate Periodic Interest rate when when comes before the first schedule
                            startDate = outputGrid[PaymentDetailIndex - 1].PaymentDate;
                            //It determines the end date. Interest will be calculated till the end date for that period.
                            endDate = outputGrid[PaymentDetailIndex].PaymentDate;
                            //This variable calls a function which calculate the periodic interest rate for that period.
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                        }
                        interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningPrincipal, true, true, false);
                        #endregion

                        #region Calculate Daily Interest rate and interest amount 
                        //This variable calculates the daily interest rate for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                        dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        //This variable calculates the daily interest amount for the period.
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                            "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                        dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                        dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                        #endregion

                        interestAccrued = Round.RoundOffAmount(interestAccrued);

                        serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                            string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.InputRecords[inputIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, outputGrid[PaymentDetailIndex].BeginningServiceFee, true, true, false);

                        serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                        interestCarryOver = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver);
                        serviceFeeInterestCarryover = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver);

                        //Calculate management and maintainance fee
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);");
                        managementFeePayable = ManagementAndMaintenanceFeeCalc.CalculateManagementFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref managementFeeTableIndex, ref lastManagementFeeChargedIndex);
                        sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, outputGridRowNumber, inputGridRow, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);");
                        maintenanceFeePayable = ManagementAndMaintenanceFeeCalc.CalculateMaintenanceFeeToCharge(scheduleInput, outputSchedule, outputGrid, PaymentDetailIndex, inputGridRowIndex, false, false, false, ref maintenanceFeeTableIndex, ref lastMaintenanceFeeChargedIndex);
                        outputGrid[PaymentDetailIndex].ManagementFee = managementFeePayable;
                        outputGrid[PaymentDetailIndex].MaintenanceFee = maintenanceFeePayable;

                        if (scheduleInput.Residual > 0)
                        {
                            #region  For the Residual operation calculate begnning principal amount
                            totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                            for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                            {
                                totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                            }
                            totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                            if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                            {
                                interestAccrued = 0;
                                dailyInterestAmount = 0;
                            }

                            #endregion
                        }
                        outputGrid[PaymentDetailIndex].InterestAccrued = Round.RoundOffAmount(interestAccrued);
                        outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);

                        if (PaymentDetailIndex != outputGrid.Count - 1)
                        {
                            #region
                            #region calculate Principal Amount and Interest Accrued and interestCarryOver amount
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = totalResidualPrincipal;
                            if ((interestAccrued + interestCarryOver) >= totalAmountToPay)
                            {
                                interestCarryOver = Round.RoundOffAmount((interestAccrued + interestCarryOver)) - Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].InterestCarryOver = Round.RoundOffAmount(interestCarryOver);
                                interestAccrued = Round.RoundOffAmount(totalAmountToPay);
                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                            }
                            else
                            {
                                if ((interestAccrued + interestCarryOver + outputGrid[PaymentDetailIndex].BeginningPrincipal) > totalAmountToPay)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalAmountToPay) - Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                                    interestAccrued = Round.RoundOffAmount((interestAccrued + interestCarryOver));
                                    interestCarryOver = 0;
                                    outputGrid[PaymentDetailIndex].InterestCarryOver = interestCarryOver;
                                }
                            }
                            #endregion

                            #region calculate serviceFee Amount and ServiceFeeInterest and serviceFeeInterestCarryover amount
                            if (scheduleInput.ServiceFeeFirstPayment)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + serviceFeeInterestCarryover + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                                totalServiceFeePayable = outputGrid[PaymentDetailIndex].ServiceFee + serviceFeeInterest;
                                serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));

                            }
                            else if ((serviceFeeInterest + serviceFeeInterestCarryover) >= totalServiceFeePayable)
                            {
                                serviceFeeInterestCarryover = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover)) - Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = Round.RoundOffAmount(serviceFeeInterestCarryover);
                                serviceFeeInterest = Round.RoundOffAmount(totalServiceFeePayable);
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                            }
                            else
                            {
                                if ((serviceFeeInterest + serviceFeeInterestCarryover + outputGrid[PaymentDetailIndex].BeginningServiceFee) > totalServiceFeePayable)
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(totalServiceFeePayable) - Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                                    outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee);
                                    serviceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + serviceFeeInterestCarryover));
                                    serviceFeeInterestCarryover = 0;
                                    outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = serviceFeeInterestCarryover;
                                }
                            }
                            #endregion

                            #region Allocate amount for the schedule
                            outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                            outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                            outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                            outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                            outputGrid[PaymentDetailIndex].BeginningPrincipal = scheduledBegnningPrinciple;

                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningPrincipal <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) ? outputGrid[PaymentDetailIndex].BeginningPrincipal : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PrincipalPastDue);
                            outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal < outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].BeginningPrincipal : outputGrid[PaymentDetailIndex].PrincipalPayment;
                            outputGrid[PaymentDetailIndex].InterestPayment = interestAccrued + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                            outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                            outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);

                            outputGrid[PaymentDetailIndex].ServiceFeeInterest = serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee == 0 ? 0 : outputGrid[PaymentDetailIndex].BeginningServiceFee <= Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) ? outputGrid[PaymentDetailIndex].BeginningServiceFee : Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFee) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeePastDue);
                            outputGrid[PaymentDetailIndex].ServiceFee = outputGrid[PaymentDetailIndex].BeginningServiceFee < outputGrid[PaymentDetailIndex].ServiceFee ? outputGrid[PaymentDetailIndex].BeginningServiceFee : outputGrid[PaymentDetailIndex].ServiceFee;
                            outputGrid[PaymentDetailIndex].PaymentDue = totalAmountToPay + totalServiceFeePayable +
                                                                         ((outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].OriginationFee - scheduleInput.EarnedOriginationFee)) +
                                                                        ((outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee) < 0 ? 0 : (outputGrid[PaymentDetailIndex].SameDayFee - scheduleInput.EarnedSameDayFee)) +
                                                                        managementFeePayable + outputGrid[PaymentDetailIndex].MaintenanceFee + totalEarnedFeePerschedule;
                            outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);


                            outputGrid[PaymentDetailIndex].MaintenanceFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue);
                            outputGrid[PaymentDetailIndex].ManagementFee += Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);

                            if (outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFee = 0;
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                            }

                            #endregion

                            #region Calculate EnforcementPrincipal Amount
                            indexCount = outputGrid.Count(o => o.PaymentDate <= outputGrid[PaymentDetailIndex].PaymentDate && (o.Flags == (int)Constants.FlagValues.Payment || o.Flags == (int)Constants.FlagValues.SkipPayment));
                            if (indexCount >= (scheduleInput.EnforcedPayment) && outputGrid[PaymentDetailIndex].PrincipalPayment == 0 && outputGrid[PaymentDetailIndex].InterestPayment > 0)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].InterestPayment <= scheduleInput.EnforcedPrincipal ? Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPayment) : Round.RoundOffAmount(scheduleInput.EnforcedPrincipal);
                                if (scheduleInput.Residual > 0)
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : totalResidualPrincipal;
                                }
                                else
                                {
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].BeginningPrincipal >= outputGrid[PaymentDetailIndex].PrincipalPayment ? outputGrid[PaymentDetailIndex].PrincipalPayment : outputGrid[PaymentDetailIndex].BeginningPrincipal;
                                }
                                outputGrid[PaymentDetailIndex].InterestPayment -= outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].InterestCarryOver += outputGrid[PaymentDetailIndex].PrincipalPayment;
                                outputGrid[PaymentDetailIndex].PrincipalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 ? 0 : outputGrid[PaymentDetailIndex].PrincipalPayment;

                            }
                            #endregion

                            #region Allocation fund on the basis of priority
                            paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) ?
                                                (scheduleInput.PaymentAmount > 0 && inputIndex < (outputGrid.Count - 1) ?
                                                    scheduleInput.PaymentAmount : outputGrid[PaymentDetailIndex].PaymentDue) :
                                                Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount);

                            if (scheduleInput.InputRecords[inputGridRow].Flags == (int)Constants.FlagValues.SkipPayment)
                            {
                                paymentAmount = 0;
                            }
                            inputGridRow = inputIndex;
                            Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                            #endregion

                            #region If Payment amount get remains after all priority allocation have done for a schedule

                            double remainningCurrentBegnningPrincipal = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid));
                            double remainningCurrentBeginningServiceFee = (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid));
                            if (PaymentDetailIndex != outputGrid.Count - 1)
                            {
                                for (int startindex = 1; startindex <= 10; startindex++)
                                {
                                    if (scheduleInput.InputRecords[inputIndex].PrincipalPriority == startindex)
                                    {
                                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                                        remainningCurrentBegnningPrincipal = scheduleInput.Residual > 0 ? (remainningCurrentBegnningPrincipal > totalResidualPrincipal ? totalResidualPrincipal : remainningCurrentBegnningPrincipal) : remainningCurrentBegnningPrincipal;
                                        if (paymentAmount >= remainningCurrentBegnningPrincipal)
                                        {
                                            outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(remainningCurrentBegnningPrincipal);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = totalResidualPrincipal > 0 ? (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid)) : 0;
                                                outputGrid[PaymentDetailIndex + 1].InterestAccrued = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBegnningPrincipal;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].PrincipalPaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningPrincipal = Round.RoundOffAmount(remainningCurrentBegnningPrincipal) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                                totalResidualPrincipal = 0;
                                            }
                                        }
                                    }
                                    if (scheduleInput.InputRecords[inputIndex].ServiceFeePriority == startindex)
                                    {
                                        if (paymentAmount >= remainningCurrentBeginningServiceFee)
                                        {
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(remainningCurrentBeginningServiceFee);
                                            if (PaymentDetailIndex != outputGrid.Count - 1)
                                            {
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = 0;
                                                outputGrid[PaymentDetailIndex + 1].AccruedServiceFeeInterest = 0;
                                            }
                                            paymentAmount = paymentAmount - remainningCurrentBeginningServiceFee;
                                        }
                                        else
                                        {
                                            if (paymentAmount > 0)
                                            {
                                                outputGrid[PaymentDetailIndex].ServiceFeePaid += Round.RoundOffAmount(paymentAmount);
                                                outputGrid[PaymentDetailIndex + 1].BeginningServiceFee = Round.RoundOffAmount(remainningCurrentBeginningServiceFee) - Round.RoundOffAmount(paymentAmount);
                                                paymentAmount = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion

                            outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                               outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                               outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                               outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                               outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                            outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                                                         outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                                                         outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid +
                                                                         outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                                                         outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                            outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                            #endregion
                        }
                        else
                        {
                            #region Allocate amount for last row of the schedule
                            AllocateLastRow(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, interestAccrued, serviceFeeInterest, periodicInterestRate, dailyInterestRate, dailyInterestAmount, maintenanceFeePayable, managementFeePayable);
                            #endregion
                        }
                        #region Allocate amount in last row of the schedule if begnning principal and begnning servicefee and other fee are goes to ziro

                        if (Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal - scheduleInput.Residual) <= 0 && outputGrid[PaymentDetailIndex].PrincipalPayment <= 0 && outputGrid[PaymentDetailIndex].InterestPayment <= 0 &&
                            outputGrid[PaymentDetailIndex].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFee <= 0 && outputGrid[PaymentDetailIndex].ServiceFeeInterest <= 0 &&
                            outputGrid[PaymentDetailIndex].OriginationFee <= 0 && outputGrid[PaymentDetailIndex].SameDayFee <= 0 && outputGrid[PaymentDetailIndex].InterestCarryOver <= 0 &&
                            outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver <= 0 && outputGrid[PaymentDetailIndex].NSFFee <= 0 && outputGrid[PaymentDetailIndex].LateFee <= 0 &&
                            outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0)
                        {
                            paymentAmount = 0; totalResidualPrincipal = 0;
                            IfLoanAmountAndAllFeeZero(inputGridRow, scheduleInput, outputGrid, outputSchedule, PaymentDetailIndex, inputIndex, paymentAmount, totalResidualPrincipal);
                        }
                        #endregion
                        #endregion
                    }
                    PaymentDetailIndex = PaymentDetailIndex + 1;
                    inputGridRowIndex++;
                }

                #region Add Extended Additional payment for Discount
                if ((additionalPaymentlDate >= (scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate == DateTime.MinValue ? scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].DateIn : scheduleInput.InputRecords[scheduleInput.InputRecords.Count - 1].EffectiveDate)) && (additionalPaymentlDate >= outputGrid[outputGrid.Count - 1].PaymentDate) && (outputGrid[outputGrid.Count - 1].InterestCarryOver > 0 || outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver > 0
                       || outputGrid[outputGrid.Count - 1].PrincipalPastDue > 0 || outputGrid[outputGrid.Count - 1].InterestPastDue > 0 || outputGrid[outputGrid.Count - 1].ServiceFeePastDue > 0
                       || outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue > 0 || outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue > 0 || outputGrid[outputGrid.Count - 1].ManagementFeePastDue > 0
                       || outputGrid[outputGrid.Count - 1].OriginationFeePastDue > 0 || outputGrid[outputGrid.Count - 1].SameDayFeePastDue > 0 || outputGrid[outputGrid.Count - 1].NSFFeePastDue > 0 || outputGrid[outputGrid.Count - 1].LateFeePastDue > 0))
                {
                    begnningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;
                    begnningServiceFee = outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningServiceFee - outputGrid[PaymentDetailIndex - 1].ServiceFeePaid)) : 0;
                    double previousBegnningPrincipal = outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid > 0 ? Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].BeginningPrincipal - outputGrid[PaymentDetailIndex - 1].PrincipalPaid)) : 0;

                    #region Calculate Priodic Intrest Rate
                    for (int startindex = outputGrid.Count - 1; startindex >= 0; startindex--)
                    {
                        if (outputGrid[startindex].Flags != (int)Constants.FlagValues.ManagementFee && outputGrid[startindex].Flags != (int)Constants.FlagValues.MaintenanceFee)
                        {
                            //Find start date
                            startDate = outputGrid[startindex].PaymentDate;
                            //Find end date
                            endDate = additionalPaymentlDate;
                            periodicInterestRate = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, true, false) :
                                    CalculatePeriodicInterestRate.CalcPeriodicInterestRateWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, true, true, false);
                            break;
                        }
                    }
                    interestAccrued = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningPrincipal, true, true, false);
                    #endregion

                    #region Calculate Daily Interest rate and interest amount 
                    //This variable calculates the daily interest rate for the period.
                    sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : DailyInterestRate.CalculateDailyInterestRate(scheduleInputs.DaysInYearBankMethod, " +
                        "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate);");
                    dailyInterestRate = DailyInterestRate.CalculateDailyInterestRate(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, periodicInterestRate, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                    //This variable calculates the daily interest amount for the period.
                    sbTracing.AppendLine("Inside LoanAmort_driver.RollingBusiness, ActualPaymentAllocation class, and Discount() Calling method : DailyInterestAmount.CalculateDailyInterestAmount(scheduleInputs.DaysInYearBankMethod, " +
                        "scheduleInputs.DaysInMonth, startDate, endDate, periodicInterestRate * principal);");
                    dailyInterestAmount = DailyInterestAmount.CalculateDailyInterestAmount(scheduleInput.DaysInYearBankMethod, scheduleInput.DaysInMonth, startDate, endDate, interestAccrued, scheduleInput.InputRecords[0].DateIn, scheduleInput.InterestDelay, scheduleInput, true);
                    dailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                    #endregion

                    interestAccrued = Round.RoundOffAmount(interestAccrued);

                    serviceFeeInterest = (scheduleInput.ApplyServiceFeeInterest == 0 || scheduleInput.ApplyServiceFeeInterest == 2) ? 0 :
                        string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].InterestRate) ? PeriodicInterestAmount.CalcAccruedInterestWithTier(scheduleInput, startDate, endDate, scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, true, false) :
                                    PeriodicInterestAmount.CalcAccruedInterestWithoutTier(scheduleInput, startDate, endDate, Convert.ToDouble(scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestRate), scheduleInput.InputRecords[0].DateIn, begnningServiceFee, true, true, false);
                    serviceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);

                    if (scheduleInput.Residual > 0)
                    {
                        #region  For the Residual operation calculate begnning principal amount
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                        {
                            totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                        }
                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;
                        if (totalResidualPrincipal <= 0 && outputGrid[PaymentDetailIndex - 1].BeginningServiceFee <= 0 && outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver <= 0 &&
                              outputGrid[PaymentDetailIndex - 1].InterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue <= 0 && outputGrid[PaymentDetailIndex - 1].InterestCarryOver <= 0 && outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue <= 0 && outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue <= 0)
                        {
                            interestAccrued = 0;
                            dailyInterestAmount = 0;
                        }
                        begnningPrincipal = totalResidualPrincipal;
                        #endregion
                    }

                    #region Add Extended Additional payment for Discount
                    totalInterestPayment = Round.RoundOffAmount((interestAccrued + outputGrid[outputGrid.Count - 1].InterestCarryOver + outputGrid[outputGrid.Count - 1].InterestPastDue));
                    totalServiceFeeInterestPayment = Round.RoundOffAmount((serviceFeeInterest + outputGrid[outputGrid.Count - 1].AccruedServiceFeeInterestCarryOver + outputGrid[outputGrid.Count - 1].ServiceFeeInterestPastDue));
                    outputGrid.Insert(PaymentDetailIndex, new PaymentDetail
                    {
                        PaymentDate = endDate,
                        BeginningPrincipal = previousBegnningPrincipal,
                        BeginningServiceFee = begnningServiceFee,
                        PeriodicInterestRate = periodicInterestRate,
                        DailyInterestRate = dailyInterestRate,
                        DailyInterestAmount = dailyInterestAmount,
                        PaymentID = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].PaymentID.ToString()),
                        Flags = Convert.ToInt32(scheduleInput.AdditionalPaymentRecords[additionalIndex].Flags.ToString()),
                        DueDate = endDate,
                        InterestAccrued = interestAccrued,
                        InterestCarryOver = 0,
                        InterestPayment = totalInterestPayment,
                        PrincipalPayment = Round.RoundOffAmount(begnningPrincipal),
                        PaymentDue = 0,
                        TotalPayment = 0,
                        AccruedServiceFeeInterest = serviceFeeInterest,
                        AccruedServiceFeeInterestCarryOver = 0,
                        ServiceFee = Round.RoundOffAmount(begnningServiceFee),
                        ServiceFeeInterest = totalServiceFeeInterestPayment,
                        OriginationFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].OriginationFeePastDue),
                        MaintenanceFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue),
                        ManagementFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].ManagementFeePastDue),
                        SameDayFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].SameDayFeePastDue),
                        NSFFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].NSFFeePastDue),
                        LateFee = Round.RoundOffAmount(outputGrid[outputGrid.Count - 1].LateFeePastDue),
                        //Paid amount columns
                        PrincipalPaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount > 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount < Round.RoundOffAmount(begnningPrincipal) ?
                                       scheduleInput.AdditionalPaymentRecords[additionalIndex].PrincipalDiscount : Round.RoundOffAmount(begnningPrincipal)) : 0,

                        InterestPaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestDiscount > 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestDiscount < totalInterestPayment ?
                                        scheduleInput.AdditionalPaymentRecords[additionalIndex].InterestDiscount : totalInterestPayment) : 0,

                        ServiceFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeDiscount > 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeDiscount < Round.RoundOffAmount(begnningServiceFee) ?
                                        scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeDiscount : Round.RoundOffAmount(begnningServiceFee)) : 0,
                        ServiceFeeInterestPaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeInterestDiscount >= 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeInterestDiscount < totalServiceFeeInterestPayment ?
                                       scheduleInput.AdditionalPaymentRecords[additionalIndex].ServiceFeeInterestDiscount : totalServiceFeeInterestPayment) : 0,

                        OriginationFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].OriginationFeeDiscount > 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].OriginationFeeDiscount < outputGrid[outputGrid.Count - 1].OriginationFeePastDue ?
                                       scheduleInput.AdditionalPaymentRecords[additionalIndex].OriginationFeeDiscount : outputGrid[outputGrid.Count - 1].OriginationFeePastDue) : 0,

                        MaintenanceFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].MaintenanceFeeDiscount > 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].MaintenanceFeeDiscount < outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue ?
                                       scheduleInput.AdditionalPaymentRecords[additionalIndex].MaintenanceFeeDiscount : outputGrid[outputGrid.Count - 1].MaintenanceFeePastDue) : 0,

                        ManagementFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].ManagementFeeDiscount > 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].ManagementFeeDiscount < outputGrid[outputGrid.Count - 1].ManagementFeePastDue ?
                                      scheduleInput.AdditionalPaymentRecords[additionalIndex].ManagementFeeDiscount : outputGrid[outputGrid.Count - 1].ManagementFeePastDue) : 0,

                        SameDayFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].SameDayFeeDiscount > 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].SameDayFeeDiscount < outputGrid[outputGrid.Count - 1].SameDayFeePastDue ?
                                        scheduleInput.AdditionalPaymentRecords[additionalIndex].SameDayFeeDiscount : outputGrid[outputGrid.Count - 1].SameDayFeePastDue) : 0,

                        NSFFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].NSFFeeDiscount > 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].NSFFeeDiscount < outputGrid[outputGrid.Count - 1].NSFFeePastDue ?
                                       scheduleInput.AdditionalPaymentRecords[additionalIndex].NSFFeeDiscount : outputGrid[outputGrid.Count - 1].NSFFeePastDue) : 0,

                        LateFeePaid = scheduleInput.AdditionalPaymentRecords[additionalIndex].LateFeeDiscount > 0 ?
                                       (scheduleInput.AdditionalPaymentRecords[additionalIndex].LateFeeDiscount < outputGrid[outputGrid.Count - 1].LateFeePastDue ?
                                        scheduleInput.AdditionalPaymentRecords[additionalIndex].LateFeeDiscount : outputGrid[outputGrid.Count - 1].LateFeePastDue) : 0,
                        TotalPaid = 0,
                        //Cumulative Amount paid column
                        CumulativeInterest = 0,
                        CumulativePrincipal = 0,
                        CumulativePayment = 0,
                        CumulativeServiceFee = 0,
                        CumulativeServiceFeeInterest = 0,
                        CumulativeServiceFeeTotal = 0,
                        CumulativeOriginationFee = 0,
                        CumulativeMaintenanceFee = 0,
                        CumulativeManagementFee = 0,
                        CumulativeSameDayFee = 0,
                        CumulativeNSFFee = 0,
                        CumulativeLateFee = 0,
                        CumulativeTotalFees = 0,
                        //Cumulative past due amount columns
                        CumulativePrincipalPastDue = 0,
                        CumulativeInterestPastDue = 0,
                        CumulativeServiceFeePastDue = 0,
                        CumulativeServiceFeeInterestPastDue = 0,
                        CumulativeOriginationFeePastDue = 0,
                        CumulativeMaintenanceFeePastDue = 0,
                        CumulativeManagementFeePastDue = 0,
                        CumulativeSameDayFeePastDue = 0,
                        CumulativeNSFFeePastDue = 0,
                        CumulativeLateFeePastDue = 0,
                        CumulativeTotalPastDue = 0,
                        BucketStatus = ""
                    });

                    outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest + outputGrid[PaymentDetailIndex].ServiceFee));
                    #endregion
                    //Past due amount columns
                    outputGrid[PaymentDetailIndex].PrincipalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPayment - outputGrid[PaymentDetailIndex].PrincipalPaid));

                    outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].InterestPayment - outputGrid[PaymentDetailIndex].InterestPaid));

                    outputGrid[PaymentDetailIndex].ServiceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee - outputGrid[PaymentDetailIndex].ServiceFeePaid));

                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest - outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid));

                    outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee - outputGrid[PaymentDetailIndex].OriginationFeePaid));

                    outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee - outputGrid[PaymentDetailIndex].MaintenanceFeePaid));

                    outputGrid[PaymentDetailIndex].ManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee - outputGrid[PaymentDetailIndex].ManagementFeePaid));

                    outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee - outputGrid[PaymentDetailIndex].SameDayFeePaid));

                    outputGrid[PaymentDetailIndex].NSFFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].NSFFee - outputGrid[PaymentDetailIndex].NSFFeePaid));

                    outputGrid[PaymentDetailIndex].LateFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].LateFee - outputGrid[PaymentDetailIndex].LateFeePaid));

                    outputGrid[PaymentDetailIndex].TotalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPastDue + outputGrid[PaymentDetailIndex].InterestPastDue
                                                                 + outputGrid[PaymentDetailIndex].ServiceFeePastDue + outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue
                                                                 + outputGrid[PaymentDetailIndex].OriginationFeePastDue + outputGrid[PaymentDetailIndex].MaintenanceFeePastDue
                                                                 + outputGrid[PaymentDetailIndex].ManagementFeePastDue + outputGrid[PaymentDetailIndex].SameDayFeePastDue
                                                                 + outputGrid[PaymentDetailIndex].NSFFeePastDue + outputGrid[PaymentDetailIndex].LateFeePastDue));
                    outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid
                                                            + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid + outputGrid[PaymentDetailIndex].ServiceFeePaid
                                                            + outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid
                                                            + outputGrid[PaymentDetailIndex].ManagementFeePaid + outputGrid[PaymentDetailIndex].MaintenanceFeePaid
                                                            + outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid));
                }
                #endregion
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        private static void Priority(int inputGridRow, getScheduleInput scheduleInput, List<PaymentDetail> outputGrid, int PaymentDetailIndex, getScheduleOutput outputSchedule, ref double paymentAmount, ref double totalResidualPrincipal)
        {
            StringBuilder sbTracing = new StringBuilder();
            try
            {
                if (paymentAmount <= 0)
                {
                    #region

                    if (scheduleInput.Residual > 0)
                    {
                        #region  For the Residual principal amount
                        double principalAmount = outputGrid[PaymentDetailIndex].PrincipalPayment;
                        totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                        for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                        {
                            totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                        }
                        totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                        if (totalResidualPrincipal > principalAmount)
                        {
                            totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - principalAmount);
                        }
                        else
                        {
                            if (totalResidualPrincipal > 0)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal;
                                totalResidualPrincipal = 0;
                            }
                            else
                            {
                                if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                        outputGrid[PaymentDetailIndex - 1].InterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                {
                                    totalResidualPrincipal = 0;
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                }
                                else
                                {
                                    totalResidualPrincipal = 0;
                                    outputGrid[PaymentDetailIndex].InterestAccrued = 0;
                                    outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                    outputGrid[PaymentDetailIndex].DailyInterestAmount = 0;
                                }
                            }
                        }

                        #endregion
                    }
                    outputGrid[PaymentDetailIndex].InterestPaid = 0;
                    outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].InterestPayment));
                    outputGrid[PaymentDetailIndex].CumulativeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].InterestPayment));

                    outputGrid[PaymentDetailIndex].PrincipalPaid = 0;
                    outputGrid[PaymentDetailIndex].PrincipalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPayment));
                    outputGrid[PaymentDetailIndex].CumulativePrincipalPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].PrincipalPayment));

                    outputGrid[PaymentDetailIndex].ServiceFeePaid = 0;
                    outputGrid[PaymentDetailIndex].ServiceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee));
                    outputGrid[PaymentDetailIndex].CumulativeServiceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee));

                    outputGrid[PaymentDetailIndex].NSFFeePaid = 0;
                    outputGrid[PaymentDetailIndex].NSFFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].NSFFee));
                    outputGrid[PaymentDetailIndex].CumulativeNSFFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].NSFFee));

                    outputGrid[PaymentDetailIndex].LateFeePaid = 0;
                    outputGrid[PaymentDetailIndex].LateFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].LateFee));
                    outputGrid[PaymentDetailIndex].CumulativeLateFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].LateFee));

                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = 0;
                    outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                    outputGrid[PaymentDetailIndex].CumulativeServiceFeeInterestPastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFeeInterest));

                    outputGrid[PaymentDetailIndex].OriginationFeePaid = 0;
                    outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee));
                    outputGrid[PaymentDetailIndex].CumulativeOriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee));

                    outputGrid[PaymentDetailIndex].ManagementFeePaid = 0;
                    outputGrid[PaymentDetailIndex].ManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee));
                    outputGrid[PaymentDetailIndex].CumulativeManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee));

                    outputGrid[PaymentDetailIndex].MaintenanceFeePaid = 0;
                    outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee));
                    outputGrid[PaymentDetailIndex].CumulativeMaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee));

                    outputGrid[PaymentDetailIndex].SameDayFeePaid = 0;
                    outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee));
                    outputGrid[PaymentDetailIndex].CumulativeSameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee));
                    #endregion
                }
                else
                {
                    #region
                    for (int i = 1; i <= 10; i++)
                    {
                        //Allocate funds to interest amount
                        if (scheduleInput.InputRecords[inputGridRow].InterestPriority == i)
                        {
                            #region
                            double interestAmount = outputGrid[PaymentDetailIndex].InterestPayment;
                            if (interestAmount <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].InterestPaid = interestAmount;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(interestAmount);
                                outputGrid[PaymentDetailIndex].InterestPastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativeInterestPastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].InterestPaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].InterestPastDue = Round.RoundOffAmount((interestAmount - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativeInterestPastDue = Round.RoundOffAmount((interestAmount - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].InterestPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestPaid);
                            #endregion
                        }

                        //Allocate funds to principal amount
                        else if (scheduleInput.InputRecords[inputGridRow].PrincipalPriority == i)
                        {
                            #region
                            double principalAmount = outputGrid[PaymentDetailIndex].PrincipalPayment;
                            if (scheduleInput.Residual > 0)
                            {
                                #region  For the Residual principal amount
                                totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                                for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                                {
                                    totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                                }
                                totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                                if (totalResidualPrincipal > principalAmount)
                                {
                                    totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - principalAmount);
                                }
                                else
                                {
                                    if (totalResidualPrincipal > 0)
                                    {
                                        outputGrid[PaymentDetailIndex].PrincipalPayment = totalResidualPrincipal;
                                        principalAmount = totalResidualPrincipal;
                                        totalResidualPrincipal = 0;
                                    }
                                    else
                                    {
                                        if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                        outputGrid[PaymentDetailIndex - 1].InterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                                        {
                                            principalAmount = 0;
                                            totalResidualPrincipal = 0;
                                            outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                        }
                                        else
                                        {
                                            principalAmount = 0;
                                            totalResidualPrincipal = 0;
                                            outputGrid[PaymentDetailIndex].InterestAccrued = 0;
                                            outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                            outputGrid[PaymentDetailIndex].DailyInterestAmount = 0;
                                        }
                                    }
                                }

                                #endregion
                            }
                            if (principalAmount <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPaid = principalAmount;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(principalAmount);
                                outputGrid[PaymentDetailIndex].PrincipalPastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativePrincipalPastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].PrincipalPaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].PrincipalPastDue = Round.RoundOffAmount((principalAmount - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativePrincipalPastDue = Round.RoundOffAmount((principalAmount - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].PrincipalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPaid);
                            #endregion
                        }

                        //Allocate funds to Service Fee amount
                        else if (scheduleInput.InputRecords[inputGridRow].ServiceFeePriority == i)
                        {
                            #region
                            double serviceFeeAmount = outputGrid[PaymentDetailIndex].ServiceFee;
                            if (serviceFeeAmount <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeePaid = serviceFeeAmount;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(serviceFeeAmount);
                                outputGrid[PaymentDetailIndex].ServiceFeePastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativeServiceFeePastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeePaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].ServiceFeePastDue = Round.RoundOffAmount((serviceFeeAmount - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativeServiceFeePastDue = Round.RoundOffAmount((serviceFeeAmount - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].ServiceFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeePaid);
                            #endregion
                        }
                        //Allocate funds to NSF Fee amount
                        else if (scheduleInput.InputRecords[inputGridRow].NSFFeePriority == i)
                        {
                            #region
                            double nsfFeeAmount = outputGrid[PaymentDetailIndex].NSFFee;
                            if (nsfFeeAmount <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].NSFFeePaid = nsfFeeAmount;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(nsfFeeAmount);
                                outputGrid[PaymentDetailIndex].NSFFeePastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativeNSFFeePastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].NSFFeePaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].NSFFeePastDue = Round.RoundOffAmount((nsfFeeAmount - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativeNSFFeePastDue = Round.RoundOffAmount((nsfFeeAmount - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].NSFFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].NSFFeePaid);
                            #endregion
                        }
                        //Allocate funds to Late Fee amount
                        else if (scheduleInput.InputRecords[inputGridRow].LateFeePriority == i)
                        {
                            #region
                            double lateFeeAmount = outputGrid[PaymentDetailIndex].LateFee;
                            if (lateFeeAmount <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].LateFeePaid = lateFeeAmount;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(lateFeeAmount);
                                outputGrid[PaymentDetailIndex].LateFeePastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativeLateFeePastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].LateFeePaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].LateFeePastDue = Round.RoundOffAmount((lateFeeAmount - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativeLateFeePastDue = Round.RoundOffAmount((lateFeeAmount - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].LateFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].LateFeePaid);
                            #endregion
                        }
                        //Allocate funds to Service Fee Interest amount
                        else if (scheduleInput.InputRecords[inputGridRow].ServiceFeeInterestPriority == i)
                        {
                            #region
                            double serviceFeeInterestAmount = outputGrid[PaymentDetailIndex].ServiceFeeInterest;
                            if (serviceFeeInterestAmount <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = serviceFeeInterestAmount;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(serviceFeeInterestAmount);
                                outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativeServiceFeeInterestPastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].ServiceFeeInterestPastDue = Round.RoundOffAmount((serviceFeeInterestAmount - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativeServiceFeeInterestPastDue = Round.RoundOffAmount((serviceFeeInterestAmount - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid);
                            #endregion
                        }

                        //Allocate funds to Origination Fee amount
                        else if (scheduleInput.InputRecords[inputGridRow].OriginationFeePriority == i)
                        {
                            #region
                            if (outputGrid[PaymentDetailIndex].OriginationFee <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].OriginationFeePaid = outputGrid[PaymentDetailIndex].OriginationFee;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFee);
                                outputGrid[PaymentDetailIndex].OriginationFeePastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativeOriginationFeePastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].OriginationFeePaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].OriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativeOriginationFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].OriginationFee - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].OriginationFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].OriginationFeePaid);
                            #endregion
                        }

                        //Allocate funds to Management Fee amount
                        else if (scheduleInput.InputRecords[inputGridRow].ManagementFeePriority == i)
                        {
                            #region
                            if (outputGrid[PaymentDetailIndex].ManagementFee <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].ManagementFeePaid = outputGrid[PaymentDetailIndex].ManagementFee;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ManagementFee);
                                outputGrid[PaymentDetailIndex].ManagementFeePastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativeManagementFeePastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].ManagementFeePaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].ManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativeManagementFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ManagementFee - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].ManagementFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].ManagementFeePaid);
                            #endregion
                        }

                        //Allocate funds to Maintenance Fee amount
                        else if (scheduleInput.InputRecords[inputGridRow].MaintenanceFeePriority == i)
                        {
                            #region
                            if (outputGrid[PaymentDetailIndex].MaintenanceFee <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].MaintenanceFeePaid = outputGrid[PaymentDetailIndex].MaintenanceFee;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].MaintenanceFee);
                                outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativeMaintenanceFeePastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].MaintenanceFeePaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].MaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativeMaintenanceFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].MaintenanceFee - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].MaintenanceFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].MaintenanceFeePaid);
                            #endregion
                        }

                        //Allocate funds to Same Day Fee amount
                        else if (scheduleInput.InputRecords[inputGridRow].SameDayFeePriority == i)
                        {
                            #region
                            if (outputGrid[PaymentDetailIndex].SameDayFee <= paymentAmount)
                            {
                                outputGrid[PaymentDetailIndex].SameDayFeePaid = outputGrid[PaymentDetailIndex].SameDayFee;
                                paymentAmount = Round.RoundOffAmount(paymentAmount) - Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFee);
                                outputGrid[PaymentDetailIndex].SameDayFeePastDue = 0;
                                outputGrid[PaymentDetailIndex].CumulativeSameDayFeePastDue = 0;
                            }
                            else
                            {
                                outputGrid[PaymentDetailIndex].SameDayFeePaid = paymentAmount;
                                outputGrid[PaymentDetailIndex].SameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee - paymentAmount));
                                outputGrid[PaymentDetailIndex].CumulativeSameDayFeePastDue = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].SameDayFee - paymentAmount));
                                paymentAmount = 0;
                            }
                            outputGrid[PaymentDetailIndex].SameDayFeePaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].SameDayFeePaid);
                            #endregion
                        }
                    }
                    #endregion
                }
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        private static void AllocateLastRow(int inputGridRow, getScheduleInput scheduleInput, List<PaymentDetail> outputGrid, getScheduleOutput outputSchedule, int PaymentDetailIndex, int inputIndex, double interestAccrued, double serviceFeeInterest, double periodicInterestRate, double dailyInterestRate, double dailyInterestAmount, double maintenanceFeePayable, double managementFeePayable)
        {
            StringBuilder sbTracing = new StringBuilder();
            double totalResidualPrincipal = 0;
            double paymentAmount = 0;
            try
            {
                #region Allocate amount for last row of the schedule
                if (PaymentDetailIndex == outputGrid.Count - 1 && scheduleInput.Residual > 0)
                {
                    #region  For the Residual principal amount
                    totalResidualPrincipal = Round.RoundOffAmount(outputSchedule.LoanAmountCalc - scheduleInput.Residual);
                    for (int x = 0; x <= PaymentDetailIndex - 1; x++)
                    {
                        totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[x].PrincipalPaid);
                    }
                    totalResidualPrincipal = totalResidualPrincipal > 0 ? totalResidualPrincipal : 0;

                    if (totalResidualPrincipal > Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex - 1].PrincipalPastDue))
                    {
                        totalResidualPrincipal = Round.RoundOffAmount(totalResidualPrincipal - outputGrid[PaymentDetailIndex].PrincipalPayment);
                        outputGrid[PaymentDetailIndex].InterestAccrued = interestAccrued;
                        outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PrincipalPayment);
                        outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestAccrued + outputGrid[PaymentDetailIndex - 1].InterestCarryOver + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                    }
                    else
                    {
                        if (totalResidualPrincipal > 0)
                        {
                            outputGrid[PaymentDetailIndex].InterestAccrued = interestAccrued;
                            outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(totalResidualPrincipal);
                            outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestAccrued + outputGrid[PaymentDetailIndex - 1].InterestCarryOver + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            totalResidualPrincipal = 0;
                        }
                        else
                        {
                            if (totalResidualPrincipal == 0 && (outputGrid[PaymentDetailIndex].BeginningServiceFee > 0 || outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver > 0 ||
                   outputGrid[PaymentDetailIndex - 1].InterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue > 0 || outputGrid[PaymentDetailIndex - 1].InterestCarryOver > 0 || outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue > 0 || outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue > 0))
                            {
                                totalResidualPrincipal = 0;
                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                outputGrid[PaymentDetailIndex].InterestAccrued = interestAccrued;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestAccrued + outputGrid[PaymentDetailIndex - 1].InterestCarryOver + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                            }
                            else
                            {
                                dailyInterestAmount = 0;
                                outputGrid[PaymentDetailIndex].InterestAccrued = 0;
                                outputGrid[PaymentDetailIndex].PrincipalPayment = 0;
                                outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].InterestCarryOver + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                                totalResidualPrincipal = 0;
                            }
                        }
                    }

                    #endregion
                }
                else
                {
                    outputGrid[PaymentDetailIndex].InterestAccrued = interestAccrued;
                    outputGrid[PaymentDetailIndex].PrincipalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                    outputGrid[PaymentDetailIndex].InterestPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].InterestAccrued + outputGrid[PaymentDetailIndex - 1].InterestCarryOver + outputGrid[PaymentDetailIndex - 1].InterestPastDue);
                }

                outputGrid[PaymentDetailIndex].OriginationFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].OriginationFeePastDue);
                outputGrid[PaymentDetailIndex].SameDayFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].SameDayFeePastDue);
                outputGrid[PaymentDetailIndex].NSFFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].NSFFeePastDue);
                outputGrid[PaymentDetailIndex].LateFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].LateFeePastDue);
                outputGrid[PaymentDetailIndex].BeginningPrincipal = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningPrincipal);
                outputGrid[PaymentDetailIndex].PeriodicInterestRate = periodicInterestRate;
                outputGrid[PaymentDetailIndex].DailyInterestRate = dailyInterestRate;
                outputGrid[PaymentDetailIndex].DailyInterestAmount = Round.RoundOffAmount(dailyInterestAmount);
                outputGrid[PaymentDetailIndex].BeginningServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterest = Round.RoundOffAmount(serviceFeeInterest);
                outputGrid[PaymentDetailIndex].ServiceFeeInterest = Round.RoundOffAmount((serviceFeeInterest + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPastDue)));
                outputGrid[PaymentDetailIndex].AccruedServiceFeeInterestCarryOver = 0;
                outputGrid[PaymentDetailIndex].InterestCarryOver = 0;
                outputGrid[PaymentDetailIndex].ServiceFee = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].BeginningServiceFee);
                outputGrid[PaymentDetailIndex].MaintenanceFee = Round.RoundOffAmount((maintenanceFeePayable + outputGrid[PaymentDetailIndex - 1].MaintenanceFeePastDue));
                outputGrid[PaymentDetailIndex].ManagementFee = Round.RoundOffAmount(managementFeePayable) + Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].ManagementFeePastDue);

                if (outputGrid[PaymentDetailIndex].BeginningServiceFee == 0)
                {
                    outputGrid[PaymentDetailIndex].ServiceFee = 0;
                    outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                }
                else
                {
                    outputGrid[PaymentDetailIndex].ServiceFeeTotal = Round.RoundOffAmount((outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest));
                }

                outputGrid[PaymentDetailIndex].TotalPayment = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                                   outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                                   outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                                   outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                                   outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                outputGrid[PaymentDetailIndex].TotalPayment = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPayment);

                outputGrid[PaymentDetailIndex].PaymentDue = outputGrid[PaymentDetailIndex].PrincipalPayment + outputGrid[PaymentDetailIndex].InterestPayment +
                                             outputGrid[PaymentDetailIndex].ServiceFee + outputGrid[PaymentDetailIndex].ServiceFeeInterest +
                                             outputGrid[PaymentDetailIndex].OriginationFee + outputGrid[PaymentDetailIndex].SameDayFee +
                                             outputGrid[PaymentDetailIndex].MaintenanceFee + outputGrid[PaymentDetailIndex].ManagementFee +
                                             outputGrid[PaymentDetailIndex].NSFFee + outputGrid[PaymentDetailIndex].LateFee;
                outputGrid[PaymentDetailIndex].PaymentDue = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].PaymentDue);

                #region Allocation fund on the basis of priority
                paymentAmount = string.IsNullOrEmpty(scheduleInput.InputRecords[inputIndex].PaymentAmount) && scheduleInput.InputRecords[inputIndex].Flags != (int)Constants.FlagValues.SkipPayment ?
                              outputGrid[PaymentDetailIndex].PaymentDue : (scheduleInput.InputRecords[inputIndex].Flags == (int)Constants.FlagValues.SkipPayment ? 0 : Convert.ToDouble(scheduleInput.InputRecords[inputIndex].PaymentAmount));
                inputGridRow = inputIndex;
                Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                #endregion
                outputGrid[PaymentDetailIndex].TotalPaid = outputGrid[PaymentDetailIndex].PrincipalPaid + outputGrid[PaymentDetailIndex].InterestPaid +
                                            outputGrid[PaymentDetailIndex].ServiceFeePaid + outputGrid[PaymentDetailIndex].ServiceFeeInterestPaid +
                                            outputGrid[PaymentDetailIndex].OriginationFeePaid + outputGrid[PaymentDetailIndex].SameDayFeePaid +
                                            outputGrid[PaymentDetailIndex].MaintenanceFeePaid + outputGrid[PaymentDetailIndex].ManagementFeePaid +
                                            outputGrid[PaymentDetailIndex].NSFFeePaid + outputGrid[PaymentDetailIndex].LateFeePaid;
                outputGrid[PaymentDetailIndex].TotalPaid = Round.RoundOffAmount(outputGrid[PaymentDetailIndex].TotalPaid);
                #endregion
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

        private static void IfLoanAmountAndAllFeeZero(int inputGridRow, getScheduleInput scheduleInput, List<PaymentDetail> outputGrid, getScheduleOutput outputSchedule, int PaymentDetailIndex, int inputIndex, double paymentAmount, double totalResidualPrincipal)
        {
            StringBuilder sbTracing = new StringBuilder();
            try
            {
                #region
                outputGrid[PaymentDetailIndex - 1].PrincipalPayment = outputGrid[PaymentDetailIndex - 1].PrincipalPaid;
                outputGrid[PaymentDetailIndex - 1].InterestPayment = Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].InterestCarryOver + outputGrid[PaymentDetailIndex - 1].InterestPayment));
                outputGrid[PaymentDetailIndex - 1].ServiceFee = outputGrid[PaymentDetailIndex - 1].ServiceFeePaid;
                outputGrid[PaymentDetailIndex - 1].ServiceFeeInterest = Round.RoundOffAmount((outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterest));
                outputGrid[PaymentDetailIndex - 1].AccruedServiceFeeInterestCarryOver = 0;
                outputGrid[PaymentDetailIndex - 1].InterestCarryOver = 0;
                outputGrid[PaymentDetailIndex - 1].OriginationFee = outputGrid[PaymentDetailIndex - 1].OriginationFeePaid;
                outputGrid[PaymentDetailIndex - 1].SameDayFee = outputGrid[PaymentDetailIndex - 1].SameDayFeePaid;
                outputGrid[PaymentDetailIndex - 1].MaintenanceFee = outputGrid[PaymentDetailIndex - 1].MaintenanceFeePaid;
                outputGrid[PaymentDetailIndex - 1].ManagementFee = outputGrid[PaymentDetailIndex - 1].ManagementFeePaid;
                outputGrid[PaymentDetailIndex - 1].PaymentDue = outputGrid[PaymentDetailIndex - 1].PrincipalPayment + outputGrid[PaymentDetailIndex - 1].InterestPayment +
                                               outputGrid[PaymentDetailIndex - 1].ServiceFee + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterest +
                                               outputGrid[PaymentDetailIndex - 1].OriginationFee + outputGrid[PaymentDetailIndex - 1].SameDayFee +
                                               outputGrid[PaymentDetailIndex - 1].MaintenanceFee + outputGrid[PaymentDetailIndex - 1].ManagementFee +
                                               outputGrid[PaymentDetailIndex - 1].NSFFee + outputGrid[PaymentDetailIndex - 1].LateFee;
                outputGrid[PaymentDetailIndex - 1].TotalPayment = outputGrid[PaymentDetailIndex - 1].PrincipalPayment + outputGrid[PaymentDetailIndex - 1].InterestPayment +
                                               outputGrid[PaymentDetailIndex - 1].ServiceFee + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterest +
                                               outputGrid[PaymentDetailIndex - 1].OriginationFee + outputGrid[PaymentDetailIndex - 1].SameDayFee +
                                               outputGrid[PaymentDetailIndex - 1].MaintenanceFee + outputGrid[PaymentDetailIndex - 1].ManagementFee +
                                               outputGrid[PaymentDetailIndex - 1].NSFFee + outputGrid[PaymentDetailIndex - 1].LateFee;
                outputGrid[PaymentDetailIndex - 1].ServiceFeeTotal = outputGrid[PaymentDetailIndex - 1].ServiceFee + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterest;

                #region Allocation fund on the basis of priority
                paymentAmount = Round.RoundOffAmount(outputGrid[PaymentDetailIndex - 1].PaymentDue);
                inputGridRow = inputIndex;
                Priority(inputGridRow, scheduleInput, outputGrid, PaymentDetailIndex, outputSchedule, ref paymentAmount, ref totalResidualPrincipal);
                #endregion

                outputGrid[PaymentDetailIndex - 1].TotalPaid = outputGrid[PaymentDetailIndex - 1].PrincipalPaid + outputGrid[PaymentDetailIndex - 1].InterestPaid +
                                                         outputGrid[PaymentDetailIndex - 1].ServiceFeePaid + outputGrid[PaymentDetailIndex - 1].ServiceFeeInterestPaid +
                                                         outputGrid[PaymentDetailIndex - 1].OriginationFeePaid + outputGrid[PaymentDetailIndex - 1].MaintenanceFeePaid +
                                                         outputGrid[PaymentDetailIndex - 1].ManagementFeePaid + outputGrid[PaymentDetailIndex - 1].SameDayFeePaid +
                                                         outputGrid[PaymentDetailIndex - 1].NSFFeePaid + outputGrid[PaymentDetailIndex - 1].LateFeePaid;
                #endregion
            }
            catch (Exception ex)
            {
                LogManager.LogManager.WriteErrorLog(ex);
            }
            finally
            {
                LogManager.LogManager.WriteTraceLog(sbTracing.ToString());
            }
        }

    }
}
